<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IdleDuelist - Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0e1a;
            --bg-secondary: #141b2d;
            --bg-tertiary: #1a2332;
            --bg-card: rgba(26, 35, 50, 0.8);
            --bg-card-hover: rgba(30, 42, 60, 0.9);
            --text-primary: #e8e8e8;
            --text-secondary: #b0b0b0;
            --text-accent: #ffd700;
            --border-color: rgba(255, 255, 255, 0.1);
            --border-hover: rgba(255, 255, 255, 0.2);
            --accent-primary: #6366f1;
            --accent-secondary: #8b5cf6;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --info: #3b82f6;
        }

        /* Tooltip System */
        .tooltip-container {
            position: relative;
            display: inline-block;
            cursor: help;
        }

        .tooltip {
            visibility: hidden;
            position: absolute;
            z-index: 1000;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            min-width: 250px;
            max-width: 400px;
            font-size: 0.9em;
            line-height: 1.5;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            margin-bottom: 5px;
            opacity: 0;
            transition: opacity 0.3s, visibility 0.3s;
            pointer-events: none;
        }

        .tooltip::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: var(--bg-tertiary);
        }

        .tooltip-container:hover .tooltip {
            visibility: visible;
            opacity: 1;
        }

        .tooltip h4 {
            color: var(--text-accent);
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        .tooltip p {
            margin: 5px 0;
            color: var(--text-secondary);
        }

        .tooltip .stat-contribution {
            color: var(--accent-primary);
            font-weight: 600;
        }

        .tooltip .stat-value {
            color: var(--text-accent);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            background-image: 
                radial-gradient(circle at 20% 30%, rgba(99, 102, 241, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(139, 92, 246, 0.1) 0%, transparent 50%);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Header */
        .game-header {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .character-info-header {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .character-name {
            font-size: 1.5em;
            font-weight: 700;
            color: var(--text-accent);
        }

        .level-badge {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
        }

        .exp-bar-container {
            flex: 1;
            max-width: 400px;
        }

        .exp-bar {
            background: var(--bg-secondary);
            border-radius: 10px;
            height: 20px;
            overflow: hidden;
            border: 1px solid var(--border-color);
            margin-top: 5px;
        }

        .exp-fill {
            background: linear-gradient(90deg, var(--success), #059669);
            height: 100%;
            transition: width 0.4s;
            box-shadow: 0 0 10px rgba(16, 185, 129, 0.4);
        }

        .exp-text {
            font-size: 0.85em;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        .logout-btn {
            background: linear-gradient(135deg, var(--danger), #dc2626);
            padding: 10px 20px;
            border-radius: 10px;
            border: none;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .logout-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
        }

        /* Navigation */
        .nav-bar {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .nav-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid var(--border-color);
        }

        .nav-btn:hover {
            background: var(--bg-card-hover);
            border-color: var(--border-hover);
            transform: translateY(-2px);
        }

        .nav-btn.active {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-color: var(--accent-primary);
        }

        /* Screen Container */
        .screen-container {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 30px;
            padding-bottom: calc(16.67vh + 60px); /* Account for persistent chat */
            border: 1px solid var(--border-color);
            min-height: 500px;
        }

        .screen {
            display: none;
        }

        .screen.active {
            display: block;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Character Sheet */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--border-color);
        }

        .stat-card h3 {
            color: var(--text-accent);
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-label {
            color: var(--text-secondary);
        }

        .stat-value {
            color: var(--text-primary);
            font-weight: 600;
        }

        .stat-bonus {
            color: var(--success);
            font-size: 0.9em;
        }

        .equipment-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .equipment-slot {
            background: var(--bg-tertiary);
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .equipment-slot:hover {
            border-color: var(--accent-primary);
            background: var(--bg-card-hover);
        }

        .equipment-slot.filled {
            border-style: solid;
            border-color: var(--accent-primary);
        }

        .equipment-slot-name {
            font-size: 0.85em;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .equipment-item {
            font-size: 1.5em;
            margin-bottom: 5px;
        }

        .equipment-icon {
            width: 48px;
            height: 48px;
            object-fit: contain;
            margin-bottom: 5px;
            image-rendering: pixelated;
        }

        .equipment-item-name {
            font-size: 0.8em;
            color: var(--text-primary);
            font-weight: 600;
        }

        /* Skills Screen */
        .skills-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .skill-points-display {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
            text-align: center;
            border: 1px solid var(--border-color);
        }

        .skill-points-display h2 {
            color: var(--text-accent);
            font-size: 2em;
            margin-bottom: 10px;
        }

        .skill-allocation {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .skill-panel {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--border-color);
        }

        .skill-panel h3 {
            color: var(--text-accent);
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .skill-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
        }

        .skill-value {
            font-size: 2em;
            font-weight: 700;
            color: var(--text-primary);
            min-width: 60px;
            text-align: center;
        }

        .skill-btn {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            border: none;
            font-size: 1.5em;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
        }

        .skill-btn.decrease {
            background: var(--danger);
            color: white;
        }

        .skill-btn.increase {
            background: var(--success);
            color: white;
        }

        .skill-btn:hover:not(:disabled) {
            transform: scale(1.1);
        }

        .skill-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .save-skills-btn {
            margin-top: 30px;
            padding: 15px 40px;
            background: linear-gradient(135deg, var(--success), #059669);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .save-skills-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.4);
        }

        /* Inventory Screen */
        .inventory-filters {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .filter-btn {
            padding: 8px 16px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-btn:hover {
            background: var(--bg-card-hover);
        }

        .filter-btn.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
        }

        .inventory-item {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .inventory-item:hover {
            border-color: var(--accent-primary);
            transform: translateY(-3px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
        }

        .inventory-item-icon {
            width: 48px;
            height: 48px;
            object-fit: contain;
            margin-bottom: 8px;
            image-rendering: pixelated;
        }

        .item-rarity {
            font-size: 0.85em;
            margin-bottom: 8px;
        }

        .item-name {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .item-stats {
            font-size: 0.85em;
            color: var(--text-secondary);
        }

        .item-actions {
            margin-top: 10px;
            display: flex;
            gap: 5px;
        }

        .item-action-btn {
            flex: 1;
            padding: 6px;
            border: none;
            border-radius: 6px;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .equip-btn {
            background: var(--success);
            color: white;
        }

        /* Combat Screen */
        .combat-container {
            max-width: 1000px;
            margin: 0 auto;
        }

        .combat-arena {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 30px 0;
            padding: 30px;
            background: var(--bg-tertiary);
            border-radius: 16px;
            border: 1px solid var(--border-color);
        }

        .combatant {
            text-align: center;
            flex: 1;
        }

        .combatant-name {
            font-size: 1.5em;
            font-weight: 700;
            margin-bottom: 15px;
        }

        .hp-bar-container {
            width: 100%;
            max-width: 300px;
            margin: 0 auto 15px;
        }

        .hp-bar {
            background: var(--bg-secondary);
            border-radius: 10px;
            height: 30px;
            overflow: hidden;
            border: 1px solid var(--border-color);
            position: relative;
        }

        .hp-fill {
            background: linear-gradient(90deg, var(--success), #059669);
            height: 100%;
            transition: width 0.4s;
        }

        .hp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: 700;
            color: white;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
            z-index: 1;
        }

        .vs-indicator {
            font-size: 2em;
            font-weight: 700;
            color: var(--danger);
            margin: 0 30px;
        }

        /* Combat Animation Styles */
        .character-icon {
            transition: transform 0.3s ease, filter 0.2s ease;
            position: relative;
            will-change: transform, filter;
        }

        .character-icon.attacking {
            animation: attackMove 0.5s ease-in-out !important;
            transition: none !important;
        }

        .character-icon.hit {
            animation: hitShake 0.4s ease-in-out !important;
            transition: none !important;
        }

        .character-icon.dodging {
            animation: dodgeMove 0.4s ease-in-out !important;
            transition: none !important;
        }

        .character-icon.parrying {
            animation: parryBlock 0.4s ease-in-out !important;
            transition: none !important;
        }

        .character-icon.missing {
            animation: missFade 0.3s ease-in-out !important;
            transition: none !important;
        }

        .character-icon.ability-cast {
            animation: abilityFlash 0.6s ease-in-out !important;
            transition: none !important;
        }

        @keyframes attackMove {
            0% { transform: translateX(0) scale(1); }
            50% { transform: translateX(30px) scale(1.1); }
            100% { transform: translateX(0) scale(1); }
        }

        @keyframes attackMoveRight {
            0% { transform: translateX(0) scale(1); }
            50% { transform: translateX(40px) scale(1.15); }
            100% { transform: translateX(0) scale(1); }
        }

        @keyframes attackMoveLeft {
            0% { transform: translateX(0) scale(1); }
            50% { transform: translateX(-40px) scale(1.15); }
            100% { transform: translateX(0) scale(1); }
        }

        @keyframes hitShake {
            0%, 100% { transform: translateX(0) rotate(0deg); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px) rotate(-5deg); }
            20%, 40%, 60%, 80% { transform: translateX(5px) rotate(5deg); }
        }

        @keyframes dodgeMove {
            0% { transform: translateX(0) translateY(0); }
            25% { transform: translateX(-20px) translateY(-10px); }
            50% { transform: translateX(-30px) translateY(-15px); }
            75% { transform: translateX(-20px) translateY(-10px); }
            100% { transform: translateX(0) translateY(0); }
        }

        @keyframes parryBlock {
            0%, 100% { transform: rotate(0deg) scale(1); }
            25% { transform: rotate(-15deg) scale(1.1); }
            50% { transform: rotate(15deg) scale(1.1); }
            75% { transform: rotate(-10deg) scale(1.05); }
        }

        @keyframes missFade {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.95); }
        }

        @keyframes abilityFlash {
            0%, 100% { filter: brightness(1) drop-shadow(0 0 0px); }
            50% { filter: brightness(1.5) drop-shadow(0 0 20px rgba(99, 102, 241, 0.8)); }
        }

        /* Floating Damage Text */
        .floating-damage {
            position: absolute;
            font-weight: 700;
            font-size: 1.5em;
            pointer-events: none;
            z-index: 1000;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            animation: floatUp 2s ease-out forwards;
        }

        .floating-damage.normal {
            color: #ff6b6b;
        }

        .floating-damage.crit {
            color: #ffd93d;
            font-size: 2em;
            animation: floatUpCrit 2.5s ease-out forwards;
        }

        .floating-damage.ability {
            color: #6bcf7f;
            font-size: 1.8em;
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0) translateX(0) scale(1);
            }
            50% {
                opacity: 1;
                transform: translateY(-50px) translateX(0) scale(1.2);
            }
            100% {
                opacity: 0;
                transform: translateY(-100px) translateX(0) scale(0.8);
            }
        }

        @keyframes floatUpCrit {
            0% {
                opacity: 1;
                transform: translateY(0) translateX(0) scale(1) rotate(0deg);
            }
            25% {
                opacity: 1;
                transform: translateY(-30px) translateX(10px) scale(1.5) rotate(5deg);
            }
            50% {
                opacity: 1;
                transform: translateY(-60px) translateX(-10px) scale(1.3) rotate(-5deg);
            }
            100% {
                opacity: 0;
                transform: translateY(-120px) translateX(0) scale(0.6) rotate(0deg);
            }
        }

        /* Hit Splat Effects */
        .hit-splat {
            position: absolute;
            width: 60px;
            height: 60px;
            pointer-events: none;
            z-index: 999;
            opacity: 0;
            animation: splatFade 0.6s ease-out forwards;
        }

        .hit-splat::before {
            content: 'üí•';
            font-size: 60px;
            display: block;
            animation: splatPulse 0.6s ease-out;
        }

        .hit-splat.crit::before {
            content: '‚ö°';
            font-size: 80px;
        }

        @keyframes splatFade {
            0% {
                opacity: 1;
                transform: scale(0.5) rotate(0deg);
            }
            50% {
                opacity: 1;
                transform: scale(1.2) rotate(180deg);
            }
            100% {
                opacity: 0;
                transform: scale(1.5) rotate(360deg);
            }
        }

        @keyframes splatPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }

        /* Dodge/Parry/Miss Text */
        .combat-status-text {
            position: absolute;
            font-weight: 700;
            font-size: 1.2em;
            pointer-events: none;
            z-index: 1000;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            animation: statusFloat 1.5s ease-out forwards;
        }

        .combat-status-text.dodge {
            color: #4ecdc4;
        }

        .combat-status-text.parry {
            color: #ffe66d;
        }

        .combat-status-text.miss {
            color: #95a5a6;
        }

        @keyframes statusFloat {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-80px) scale(0.8);
            }
        }

        .combat-controls {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid var(--border-color);
        }

        .combat-actions {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .combat-action-btn {
            flex: 1;
            min-width: 120px;
            padding: 12px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .combat-action-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
        }

        .combat-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .auto-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: var(--bg-secondary);
            border-radius: 13px;
            cursor: pointer;
            transition: all 0.3s;
            border: 1px solid var(--border-color);
        }

        .toggle-switch.active {
            background: var(--success);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: all 0.3s;
        }

        .toggle-switch.active::after {
            left: 26px;
        }

        .combat-log {
            background: rgba(10, 14, 26, 0.9);
            border-radius: 12px;
            padding: 20px;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .combat-log-entry {
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .combat-log-entry:last-child {
            border-bottom: none;
        }


        /* Chat Screen */
        .chat-container {
            display: flex;
            flex-direction: column;
            height: 600px;
        }

        .chat-messages {
            flex: 1;
            background: rgba(10, 14, 26, 0.9);
            border-radius: 12px;
            padding: 15px;
            overflow-y: auto;
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
        }


        .chat-message {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
        }

        .chat-message-header {
            display: flex;
            gap: 10px;
            margin-bottom: 5px;
        }

        .chat-character-name {
            font-weight: 600;
            color: var(--accent-primary);
        }

        .chat-timestamp {
            font-size: 0.85em;
            color: var(--text-secondary);
        }

        .chat-message-text {
            color: var(--text-primary);
        }

        .chat-input-container {
            display: flex;
            gap: 10px;
        }

        .chat-input {
            flex: 1;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 16px;
        }

        .chat-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2);
        }

        .chat-send-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .chat-send-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
        }

        /* Character Creation Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            border: 1px solid var(--border-color);
        }

        .modal-content h2 {
            margin-bottom: 20px;
            color: var(--text-accent);
        }

        .modal-input {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 16px;
            margin-bottom: 20px;
        }

        .modal-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
        }

        .modal-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .modal-btn-primary {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: white;
        }

        .modal-btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        /* Rarity Colors */
        .rarity-common { color: #9ca3af; }
        .rarity-uncommon { color: #10b981; }
        .rarity-rare { color: #3b82f6; }
        .rarity-epic { color: #8b5cf6; }
        .rarity-legendary { color: #f59e0b; }
        .rarity-mythic { color: #ef4444; }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent-primary);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-secondary);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="game-header">
            <div class="character-info-header">
                <div>
                    <div class="character-name" id="character-name">Loading...</div>
                    <div class="exp-bar-container">
                        <div class="exp-text">
                            Level <span id="character-level">1</span> | 
                            EXP: <span id="character-exp">0</span> / <span id="character-exp-next">100</span>
                        </div>
                        <div class="exp-bar">
                            <div class="exp-fill" id="exp-fill" style="width: 0%"></div>
                        </div>
                    </div>
                </div>
                <div class="level-badge">Lv. <span id="level-display">1</span></div>
            </div>
            <div style="display: flex; align-items: center; gap: 20px;">
                <div style="color: var(--text-secondary); font-size: 0.9em;">
                    Total Players Online: <span id="online-count" style="color: var(--text-accent); font-weight: 600;">-</span>
                </div>
                <button class="logout-btn" onclick="logout()">Logout</button>
            </div>
        </div>

        <!-- Navigation -->
        <div class="nav-bar">
            <button class="nav-btn active" onclick="showScreen('character')">Character</button>
            <button class="nav-btn" onclick="showScreen('skills')">Skills</button>
            <button class="nav-btn" onclick="showScreen('inventory')">Inventory</button>
            <button class="nav-btn" onclick="showScreen('combat')">Combat</button>
            <button class="nav-btn" onclick="showScreen('store')">Store</button>
            <button class="nav-btn" onclick="showScreen('leaderboard')">Leaderboard</button>
            <button class="nav-btn" onclick="showScreen('chat')">Chat</button>
        </div>

        <!-- Screen Container -->
        <div class="screen-container">
            <!-- Character Screen -->
            <div id="character-screen" class="screen active">
                <h2 style="margin-bottom: 20px;">Character Sheet</h2>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <h3>Primary Stats</h3>
                        <div id="primary-stats"></div>
                    </div>
                    <div class="stat-card">
                        <h3>Combat Stats</h3>
                        <div id="combat-stats"></div>
                    </div>
                </div>

                <h3 style="margin-top: 30px; margin-bottom: 15px;">Equipment</h3>
                <div class="equipment-grid" id="equipment-grid"></div>
                
                <h3 style="margin-top: 30px; margin-bottom: 15px;">PvP Stats</h3>
                <div class="stat-card" id="pvp-stats-card" style="padding: 15px; background: var(--bg-tertiary); border-radius: 8px; border: 1px solid var(--border-color);">
                    <div class="stat-row" style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <span class="stat-label">PvP Wins:</span>
                        <span class="stat-value" id="pvp-wins-display">0</span>
                    </div>
                    <div class="stat-row" style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <span class="stat-label">PvP Losses:</span>
                        <span class="stat-value" id="pvp-losses-display">0</span>
                    </div>
                    <div class="stat-row" style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <span class="stat-label">Win Rate:</span>
                        <span class="stat-value" id="pvp-win-rate-display">0%</span>
                    </div>
                    <div class="stat-row" style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <span class="stat-label">MMR:</span>
                        <span class="stat-value" id="pvp-mmr-display" style="color: var(--text-accent);">1000</span>
                    </div>
                    <div class="stat-row" style="display: flex; justify-content: space-between;">
                        <span class="stat-label">MMR Rank:</span>
                        <span class="stat-value" id="pvp-rank-display">-</span>
                    </div>
                </div>
            </div>

            <!-- Skills Screen -->
            <div id="skills-screen" class="screen">
                <div class="skills-container">
                    <div class="skill-points-display">
                        <h2 id="available-points">0</h2>
                        <p>Available Skill Points</p>
                    </div>

                    <div class="skill-allocation" id="skill-allocation"></div>

                    <div style="text-align: center;">
                        <button class="save-skills-btn" onclick="saveSkills()">Save Skill Allocation</button>
                        <button class="save-skills-btn" onclick="resetSkillPoints()" style="background: var(--accent-secondary); margin-top: 10px;">Reset Skills (Respec)</button>
                    </div>
                </div>
            </div>

            <!-- Inventory Screen -->
            <div id="inventory-screen" class="screen">
                <h2 style="margin-bottom: 20px;">Inventory</h2>
                
                <div class="inventory-filters" style="margin-bottom: 15px;">
                    <button class="filter-btn active" onclick="filterInventory('all')">All</button>
                    <button class="filter-btn" onclick="filterInventory('common')">Common</button>
                    <button class="filter-btn" onclick="filterInventory('uncommon')">Uncommon</button>
                    <button class="filter-btn" onclick="filterInventory('rare')">Rare</button>
                    <button class="filter-btn" onclick="filterInventory('epic')">Epic</button>
                    <button class="filter-btn" onclick="filterInventory('legendary')">Legendary</button>
                    <button class="filter-btn" onclick="filterInventory('mythic')">Mythic</button>
                </div>
                
                <div style="margin-bottom: 15px; display: flex; gap: 10px; align-items: center;">
                    <span style="color: var(--text-secondary);">Sort by:</span>
                    <button class="filter-btn" onclick="sortInventory('name')">Name</button>
                    <button class="filter-btn" onclick="sortInventory('rarity')">Rarity</button>
                    <button class="filter-btn" onclick="sortInventory('level')">Level</button>
                    <button class="filter-btn" onclick="sortInventory('slot')">Slot</button>
                </div>

                <div class="inventory-grid" id="inventory-grid"></div>
            </div>

            <!-- Combat Screen -->
            <div id="combat-screen" class="screen">
                <div class="combat-container">
                    <h2 style="margin-bottom: 20px;">Combat</h2>
                    
                    <!-- Combat Selection (shown when no active combat) -->
                    <div id="combat-selection" style="display: block;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                            <!-- PvE Section -->
                            <div>
                                <h3 style="margin-bottom: 15px;">PvE Enemies</h3>
                                <div id="pve-enemy-list" style="max-height: 400px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 10px; padding: 10px;">
                                    <p style="text-align: center; color: var(--text-secondary);">Loading enemies...</p>
                                </div>
                            </div>
                            
                            <!-- PvP Section -->
                            <div>
                                <h3 style="margin-bottom: 15px;">PvP</h3>
                                <div style="margin-bottom: 15px;">
                                    <button class="combat-action-btn" onclick="togglePvPEnabled()" id="pvp-toggle-btn">Enable PvP</button>
                                </div>
                                <div id="pvp-opponent-list" style="max-height: 350px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 10px; padding: 10px;">
                                    <p style="text-align: center; color: var(--text-secondary);">Loading opponents...</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Active Combat (shown during combat) -->
                    <div id="active-combat" style="display: none;">
                        <div class="combat-arena" id="combat-arena" style="position: relative; min-height: 300px;">
                            <div class="combatant" style="position: relative;">
                                <div class="character-icon-container" id="player-icon-container" style="position: relative; width: 100px; height: 100px; margin: 0 auto 10px;">
                                    <div class="character-icon" id="player-icon" style="width: 100px; height: 100px; background: var(--accent-primary); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 2em; transition: transform 0.3s ease;">‚öîÔ∏è</div>
                                </div>
                                <div class="combatant-name" id="player-combat-name">Player</div>
                                <div class="hp-bar-container">
                                    <div class="hp-bar">
                                        <div class="hp-fill" id="player-hp-fill" style="width: 100%"></div>
                                        <div class="hp-text" id="player-hp-text">250/250</div>
                                    </div>
                                </div>
                                <div id="player-status-effects" style="display: flex; gap: 5px; margin-top: 5px; justify-content: center; flex-wrap: wrap; min-height: 24px;"></div>
                                <div style="margin-top: 10px; font-size: 0.9em; color: var(--text-secondary);">
                                    Mana: <span id="player-mana-text">100/100</span>
                                </div>
                            </div>
                            <div class="vs-indicator">VS</div>
                            <div class="combatant" style="position: relative;">
                                <div class="character-icon-container" id="opponent-icon-container" style="position: relative; width: 100px; height: 100px; margin: 0 auto 10px;">
                                    <div class="character-icon" id="opponent-icon" style="width: 100px; height: 100px; background: var(--danger); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 2em; transition: transform 0.3s ease;">üëπ</div>
                                </div>
                                <div class="combatant-name" id="opponent-combat-name">Opponent</div>
                                <div class="hp-bar-container">
                                    <div class="hp-bar">
                                        <div class="hp-fill" id="opponent-hp-fill" style="width: 100%"></div>
                                        <div class="hp-text" id="opponent-hp-text">250/250</div>
                                    </div>
                                </div>
                                <div id="opponent-status-effects" style="display: flex; gap: 5px; margin-top: 5px; justify-content: center; flex-wrap: wrap; min-height: 24px;"></div>
                            </div>
                            <!-- Floating damage numbers container -->
                            <div id="damage-numbers-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: hidden;"></div>
                        </div>

                        <!-- Ability Hotkey Bar -->
                        <div style="margin: 20px 0; padding: 15px; background: var(--bg-tertiary); border-radius: 12px; border: 1px solid var(--border-color);">
                            <h4 style="margin-bottom: 10px;">Abilities</h4>
                            <div id="ability-hotkeys" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px;">
                                <!-- Abilities will be populated here -->
                            </div>
                        </div>

                        <div class="combat-controls">
                            <div style="display: flex; gap: 20px; margin-bottom: 15px; flex-wrap: wrap;">
                                <div class="auto-toggle">
                                    <span>Auto Attack:</span>
                                    <div class="toggle-switch" id="auto-attack-toggle" onclick="toggleAutoAttack()"></div>
                                </div>
                                <div class="auto-toggle">
                                    <span>Auto Ability:</span>
                                    <div class="toggle-switch" id="auto-ability-toggle" onclick="toggleAutoAbility()"></div>
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <span>Stance:</span>
                                    <select id="combat-stance-select" onchange="updateCombatStance()" style="padding: 5px 10px; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 6px;">
                                        <option value="balanced">Balanced</option>
                                        <option value="offensive">Offensive</option>
                                        <option value="defensive">Defensive</option>
                                    </select>
                                </div>
                            </div>
                            <button class="combat-action-btn" onclick="endCombat()" style="background: var(--danger);">End Combat</button>
                        </div>

                        <div class="combat-log" id="combat-log"></div>
                    </div>
                </div>
            </div>
            
            <!-- Store Screen -->
            <div id="store-screen" class="screen">
                <h2 style="margin-bottom: 20px;">Store</h2>
                <div style="margin-bottom: 20px; padding: 15px; background: var(--bg-tertiary); border-radius: 12px; border: 1px solid var(--border-color);">
                    <strong>Gold: <span id="gold-balance">0</span></strong>
                </div>
                
                <div style="margin-bottom: 20px; padding: 15px; background: var(--bg-tertiary); border-radius: 12px; border: 1px solid var(--border-color);">
                    <h3 style="margin-bottom: 10px;">Forge Items</h3>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="combat-action-btn" onclick="forgeItem('uncommon')">Forge Uncommon (2000g)</button>
                        <button class="combat-action-btn" onclick="forgeItem('rare')">Forge Rare (5000g)</button>
                    </div>
                </div>
                
                <div class="inventory-grid" id="store-items-grid"></div>
            </div>

            <!-- Leaderboard Screen -->
            <div id="leaderboard-screen" class="screen">
                <h2 style="margin-bottom: 20px;">PvP Leaderboard</h2>
                <div id="leaderboard-content" style="max-height: 500px; overflow-y: auto;">
                    <p style="text-align: center; color: var(--text-secondary);">Loading leaderboard...</p>
                </div>
            </div>

            <!-- Chat Screen -->
            <div id="chat-screen" class="screen">
                <h2 style="margin-bottom: 20px;">Global Chat</h2>
                <div class="chat-container">
                    <div class="chat-messages" id="chat-messages"></div>
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <input type="text" id="chat-input" placeholder="Type your message..." maxlength="500" style="flex: 1; padding: 12px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 14px;" onkeypress="if(event.key==='Enter') sendChatMessage()">
                        <button class="combat-action-btn" onclick="sendChatMessage()">Send</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Skill Info Modal -->
    <div class="modal" id="skill-info-modal" onclick="if(event.target.id === 'skill-info-modal') closeSkillInfoModal()">
        <div class="modal-content" style="max-width: 600px; max-height: 80vh; overflow-y: auto;">
            <div id="skill-info-content"></div>
            <div class="modal-buttons" style="margin-top: 20px;">
                <button class="modal-btn modal-btn-primary" onclick="closeSkillInfoModal()" style="width: 100%;">Close</button>
            </div>
        </div>
    </div>

    <!-- Character Creation Modal -->
    <div class="modal" id="character-modal">
        <div class="modal-content">
            <h2>Create Your Character</h2>
            <input type="text" class="modal-input" id="character-name-input" placeholder="Enter character name" maxlength="20">
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-secondary" onclick="closeCharacterModal()">Cancel</button>
                <button class="modal-btn modal-btn-primary" onclick="createCharacter()">Create</button>
            </div>
        </div>
    </div>
    
    <!-- Auto-Fight Modal -->
    <div class="modal" id="auto-fight-modal">
        <div class="modal-content" style="max-width: 500px;">
            <h2>Auto-Fight Session</h2>
            <div style="margin-bottom: 20px;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <span>Time Remaining:</span>
                    <span id="auto-fight-time" style="font-weight: 600; color: var(--text-accent);">60:00</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                    <span>Wins:</span>
                    <span id="auto-fight-wins" style="color: var(--success);">0</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                    <span>Losses:</span>
                    <span id="auto-fight-losses" style="color: var(--danger);">0</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                    <span>EXP Gained:</span>
                    <span id="auto-fight-exp" style="color: var(--text-accent);">0</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                    <span>Gold Gained:</span>
                    <span id="auto-fight-gold" style="color: var(--text-accent);">0</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                    <span>Items Dropped:</span>
                    <span id="auto-fight-items" style="color: var(--text-accent);">0</span>
                </div>
            </div>
            <div id="auto-fight-results" style="display: none; margin-bottom: 20px; padding: 15px; background: var(--bg-tertiary); border-radius: 8px;"></div>
            <div style="margin-bottom: 15px; padding: 15px; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border-color);">
                <h4 style="margin-bottom: 10px; font-size: 0.95em;">Extend Session</h4>
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <button class="modal-btn modal-btn-secondary" onclick="extendAutoFight(1)" style="flex: 1; min-width: 80px; font-size: 0.9em;">+1 Hour (2,000g)</button>
                    <button class="modal-btn modal-btn-secondary" onclick="extendAutoFight(2)" style="flex: 1; min-width: 80px; font-size: 0.9em;">+2 Hours (3,500g)</button>
                    <button class="modal-btn modal-btn-secondary" onclick="extendAutoFight(4)" style="flex: 1; min-width: 80px; font-size: 0.9em;">+4 Hours (6,000g)</button>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="modal-btn modal-btn-secondary" onclick="stopAutoFight()">Stop Early</button>
                <button class="modal-btn modal-btn-primary" onclick="closeAutoFightModal()" id="auto-fight-close-btn" style="display: none;">Close</button>
            </div>
        </div>
    </div>

    <script>
        // Global state
        const TOKEN_KEY = 'idleAccessToken';
        const REFRESH_TOKEN_KEY = 'idleRefreshToken';
        const USER_ID_KEY = 'idleUserId';
        const CHARACTER_ID_KEY = 'idleCharacterId';
        const USERNAME_KEY = 'idleUsername';
        let currentUserId = localStorage.getItem(USER_ID_KEY);
        let currentCharacterId = localStorage.getItem(CHARACTER_ID_KEY);
        let characterData = null;
        
        // Helper function to get auth headers
        function getAuthHeaders() {
            const token = localStorage.getItem(TOKEN_KEY);
            const headers = { 'Content-Type': 'application/json' };
            if (token) {
                headers['Authorization'] = `Bearer ${token}`;
            }
            return headers;
        }
        
        // Helper function to handle token refresh
        async function refreshAccessToken() {
            const refreshToken = localStorage.getItem(REFRESH_TOKEN_KEY);
            if (!refreshToken) {
                window.location.href = '/';
                return null;
            }
            
            try {
                const response = await fetch('/api/auth/refresh', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ refresh_token: refreshToken })
                });
                
                const result = await response.json();
                if (result.success) {
                    localStorage.setItem(TOKEN_KEY, result.access_token);
                    return result.access_token;
                } else {
                    // Refresh token expired, redirect to login
                    localStorage.clear();
                    window.location.href = '/';
                    return null;
                }
            } catch (error) {
                localStorage.clear();
                window.location.href = '/';
                return null;
            }
        }
        
        // Wrapper for fetch that handles authentication
        async function authenticatedFetch(url, options = {}) {
            const headers = getAuthHeaders();
            if (options.headers) {
                Object.assign(headers, options.headers);
            }
            options.headers = headers;
            
            let response = await fetch(url, options);
            
            // If 401, try to refresh token
            if (response.status === 401) {
                const newToken = await refreshAccessToken();
                if (newToken) {
                    headers['Authorization'] = `Bearer ${newToken}`;
                    options.headers = headers;
                    response = await fetch(url, options);
                }
            }
            
            return response;
        }
        let skillAllocation = {};
        let currentInventoryFilter = 'all';
        let chatPollInterval = null;
        let currentCombatId = null;
        let combatPollInterval = null;
        let abilityLoadout = {};
        let currentAutoFightSessionId = null;
        let autoFightPollInterval = null;

        // Initialize
        window.addEventListener('DOMContentLoaded', async () => {
            // Check if user is authenticated
            const token = localStorage.getItem(TOKEN_KEY);
            if (!token) {
                alert('You are not logged in. Redirecting to login page...');
                window.location.href = '/';
                return;
            }
            
            // Check URL params for character creation
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('create_character') === 'true') {
                showCharacterModal();
            } else if (urlParams.get('character_id')) {
                currentCharacterId = urlParams.get('character_id');
                localStorage.setItem(CHARACTER_ID_KEY, currentCharacterId);
                await refreshCharacterData();
            } else {
                await loadCharacter();
            }

            // Start chat polling
            loadChatMessages();
            chatPollInterval = setInterval(loadChatMessages, 2000);
            
            // Start online count polling
            updateOnlineCount();
            setInterval(updateOnlineCount, 30000); // Update every 30 seconds
        });

        // Character Management
        async function loadCharacter() {
            if (currentCharacterId) {
                await refreshCharacterData();
                return;
            }
            if (!currentUserId) {
                showCharacterModal();
                return;
            }
            try {
                const response = await authenticatedFetch(`/api/character/list`);
                const result = await response.json();
                
                if (result.success && result.characters.length > 0) {
                    currentCharacterId = result.characters[0].id;
                    localStorage.setItem(CHARACTER_ID_KEY, currentCharacterId);
                    await refreshCharacterData();
                } else {
                    showCharacterModal();
                }
            } catch (error) {
                console.error('Error loading character:', error);
                showCharacterModal();
            }
        }

        async function refreshCharacterData() {
            if (!currentCharacterId) return;

            try {
                const response = await authenticatedFetch(`/api/character/${currentCharacterId}`);
                if (!response.ok) {
                    if (response.status === 404) {
                        localStorage.removeItem(CHARACTER_ID_KEY);
                        currentCharacterId = null;
                        characterData = null;
                        showCharacterModal();
                    }
                    return;
                }
                const result = await response.json();
                
                if (result.success) {
                    characterData = result.character;
                    updateUI();
                }
            } catch (error) {
                console.error('Error refreshing character:', error);
            }
        }

        function updateUI() {
            if (!characterData) return;

            // Update header
            document.getElementById('character-name').textContent = characterData.name;
            document.getElementById('character-level').textContent = characterData.level;
            document.getElementById('level-display').textContent = characterData.level;
            document.getElementById('character-exp').textContent = characterData.exp;
            
            // Calculate EXP for next level
            const expForNext = calculateExpForNextLevel(characterData.level);
            document.getElementById('character-exp-next').textContent = expForNext;
            
            const expPercent = (characterData.exp / expForNext) * 100;
            document.getElementById('exp-fill').style.width = Math.min(expPercent, 100) + '%';

            // Update character screen
            updateCharacterScreen();
            updateSkillsScreen();
            updateInventoryScreen();
            updateGoldDisplay();
            
            // Load PvE enemies if on combat screen
            if (document.getElementById('combat-screen').classList.contains('active')) {
                loadPvEEnemies();
                loadPvPOpponents();
            }
        }
        
        function updateGoldDisplay() {
            if (characterData && characterData.gold !== undefined) {
                const goldEl = document.getElementById('gold-balance');
                if (goldEl) {
                    goldEl.textContent = characterData.gold;
                }
            }
        }

        function calculateExpForNextLevel(level) {
            if (level >= 100) return 0;
            return Math.floor(Math.pow(level, 2.5) * 100);
        }

        function updateCharacterScreen() {
            // Primary stats
            const primaryStatsEl = document.getElementById('primary-stats');
            primaryStatsEl.innerHTML = '';
            
            const statNames = {
                might: 'Might',
                agility: 'Agility',
                vitality: 'Vitality',
                intellect: 'Intellect',
                wisdom: 'Wisdom',
                charisma: 'Charisma'
            };

            for (const [stat, name] of Object.entries(statNames)) {
                const baseValue = characterData.stats[stat] || 0;
                const equipmentBonus = getEquipmentStatBonus(stat);
                const totalValue = baseValue + equipmentBonus;

                const row = document.createElement('div');
                row.className = 'stat-row tooltip-container';
                const tooltipContent = getPrimaryStatTooltip(stat, totalValue);
                row.innerHTML = `
                    <span class="stat-label">${name}:</span>
                    <span>
                        <span class="stat-value">${totalValue}</span>
                        ${equipmentBonus > 0 ? `<span class="stat-bonus">(+${equipmentBonus})</span>` : ''}
                    </span>
                    <div class="tooltip">${tooltipContent}</div>
                `;
                primaryStatsEl.appendChild(row);
            }

            // Combat stats
            const combatStatsEl = document.getElementById('combat-stats');
            combatStatsEl.innerHTML = '';
            
            const combatStatNames = {
                attack_power: 'Attack Power',
                defense: 'Defense',
                crit_chance: 'Crit Chance',
                dodge_chance: 'Dodge Chance',
                parry_chance: 'Parry Chance',
                speed: 'Speed',
                spell_power: 'Spell Power',
                max_hp: 'Max HP',
                max_mana: 'Max Mana',
                mana_regen_per_second: 'Mana Regen/sec'
            };

            for (const [stat, name] of Object.entries(combatStatNames)) {
                const value = characterData.combat_stats[stat] || 0;
                let displayValue;
                if (stat.includes('chance')) {
                    displayValue = (value * 100).toFixed(2) + '%';
                } else if (stat === 'mana_regen_per_second') {
                    displayValue = value.toFixed(2) + '/s';
                } else {
                    displayValue = Math.floor(value);
                }

                const row = document.createElement('div');
                row.className = 'stat-row tooltip-container';
                const tooltipContent = getCombatStatTooltip(stat, value, characterData.stats);
                row.innerHTML = `
                    <span class="stat-label">${name}:</span>
                    <span class="stat-value">${displayValue}</span>
                    <div class="tooltip">${tooltipContent}</div>
                `;
                combatStatsEl.appendChild(row);
            }

            // PvP Stats
            if (characterData.pvp_wins !== undefined) {
                document.getElementById('pvp-wins-display').textContent = characterData.pvp_wins || 0;
                document.getElementById('pvp-losses-display').textContent = characterData.pvp_losses || 0;
                document.getElementById('pvp-win-rate-display').textContent = (characterData.pvp_win_rate || 0).toFixed(2) + '%';
                document.getElementById('pvp-mmr-display').textContent = characterData.pvp_mmr || 1000;
                // MMR rank will be loaded from leaderboard
                document.getElementById('pvp-rank-display').textContent = '-';
            }

            // PvP Stats
            if (characterData.pvp_wins !== undefined) {
                document.getElementById('pvp-wins-display').textContent = characterData.pvp_wins || 0;
                document.getElementById('pvp-losses-display').textContent = characterData.pvp_losses || 0;
                document.getElementById('pvp-win-rate-display').textContent = (characterData.pvp_win_rate || 0).toFixed(2) + '%';
                document.getElementById('pvp-mmr-display').textContent = characterData.pvp_mmr || 1000;
                // MMR rank will be loaded from leaderboard
                document.getElementById('pvp-rank-display').textContent = '-';
            }
            
            // Equipment grid
            const equipmentGrid = document.getElementById('equipment-grid');
            equipmentGrid.innerHTML = '';

            const slotNames = {
                helmet: 'Helmet',
                chest: 'Chest',
                legs: 'Legs',
                boots: 'Boots',
                gloves: 'Gloves',
                main_hand: 'Main Hand',
                off_hand: 'Off Hand'
            };

            for (const [slot, name] of Object.entries(slotNames)) {
                const slotDiv = document.createElement('div');
                slotDiv.className = 'equipment-slot tooltip-container';
                const item = characterData.equipment[slot];
                
                if (item) {
                    slotDiv.classList.add('filled');
                    const iconPath = getItemIconPath(slot, item.weapon_type, item.rarity);
                    const weaponTooltip = item.weapon_type ? getWeaponTooltip(item.weapon_type) : '';
                    slotDiv.innerHTML = `
                        <div class="equipment-slot-name">${name}</div>
                        <img src="${iconPath}" alt="${item.name}" class="equipment-icon" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                        <div class="equipment-item" style="display: none;">‚öîÔ∏è</div>
                        <div class="equipment-item-name rarity-${item.rarity}">${item.name}</div>
                        ${weaponTooltip ? `<div class="tooltip" style="min-width: 300px;">${weaponTooltip}</div>` : ''}
                    `;
                } else {
                    slotDiv.innerHTML = `
                        <div class="equipment-slot-name">${name}</div>
                        <div class="equipment-item">+</div>
                    `;
                }
                
                equipmentGrid.appendChild(slotDiv);
            }
        }

        function getEquipmentStatBonus(stat) {
            let total = 0;
            for (const item of Object.values(characterData.equipment)) {
                if (item && item.stats && item.stats[stat]) {
                    total += item.stats[stat];
                }
            }
            return total;
        }

        function getPrimaryStatTooltip(stat, totalValue) {
            const tooltips = {
                might: `
                    <h4>Might</h4>
                    <p><strong>Current Value:</strong> <span class="stat-value">${totalValue}</span></p>
                    <p><strong>Affects:</strong></p>
                    <p>‚Ä¢ <span class="stat-contribution">Attack Power</span>: +2 per point</p>
                    <p>‚Ä¢ <span class="stat-contribution">Max HP</span>: +2 per point</p>
                    <p>‚Ä¢ <span class="stat-contribution">Parry Chance</span>: +0.1% per point (max 15%)</p>
                    <p>‚Ä¢ <span class="stat-contribution">Defense</span>: +0.5 per point</p>
                    <p style="margin-top: 8px; color: var(--text-accent);"><strong>Best for:</strong> Melee fighters, tanks</p>
                `,
                agility: `
                    <h4>Agility</h4>
                    <p><strong>Current Value:</strong> <span class="stat-value">${totalValue}</span></p>
                    <p><strong>Affects:</strong></p>
                    <p>‚Ä¢ <span class="stat-contribution">Attack Power</span>: +1 per point</p>
                    <p>‚Ä¢ <span class="stat-contribution">Attack Speed</span>: Affects weapon attack speed</p>
                    <p>‚Ä¢ <span class="stat-contribution">Dodge Chance</span>: +0.15% per point (max 25%)</p>
                    <p>‚Ä¢ <span class="stat-contribution">Crit Chance</span>: +0.1% per point (max 50%)</p>
                    <p>‚Ä¢ <span class="stat-contribution">Speed</span>: +1 per point</p>
                    <p style="margin-top: 8px; color: var(--text-accent);"><strong>Best for:</strong> Rangers, rogues, fast attackers</p>
                `,
                vitality: `
                    <h4>Vitality</h4>
                    <p><strong>Current Value:</strong> <span class="stat-value">${totalValue}</span></p>
                    <p><strong>Affects:</strong></p>
                    <p>‚Ä¢ <span class="stat-contribution">Max HP</span>: +6 per point</p>
                    <p>‚Ä¢ <span class="stat-contribution">Defense</span>: +2 per point</p>
                    <p>‚Ä¢ <span class="stat-contribution">Parry Chance</span>: +0.05% per point</p>
                    <p>‚Ä¢ <span class="stat-contribution">Magic Resistance</span>: +0.25 per point</p>
                    <p style="margin-top: 8px; color: var(--text-accent);"><strong>Best for:</strong> Tanks, survivability builds</p>
                `,
                intellect: `
                    <h4>Intellect</h4>
                    <p><strong>Current Value:</strong> <span class="stat-value">${totalValue}</span></p>
                    <p><strong>Affects:</strong></p>
                    <p>‚Ä¢ <span class="stat-contribution">Spell Power</span>: +2 per point</p>
                    <p>‚Ä¢ <span class="stat-contribution">Max Mana</span>: +3 per point</p>
                    <p>‚Ä¢ <span class="stat-contribution">Crit Chance</span>: +0.05% per point (spells)</p>
                    <p>‚Ä¢ <span class="stat-contribution">Attack Power</span>: +0.5 per point</p>
                    <p style="margin-top: 8px; color: var(--text-accent);"><strong>Best for:</strong> Mages, spellcasters</p>
                `,
                wisdom: `
                    <h4>Wisdom</h4>
                    <p><strong>Current Value:</strong> <span class="stat-value">${totalValue}</span></p>
                    <p><strong>Affects:</strong></p>
                    <p>‚Ä¢ <span class="stat-contribution">Mana Regen</span>: +0.1 per second per point</p>
                    <p>‚Ä¢ <span class="stat-contribution">Spell Power</span>: +1 per point</p>
                    <p>‚Ä¢ <span class="stat-contribution">Magic Resistance</span>: +0.5 per point</p>
                    <p>‚Ä¢ <span class="stat-contribution">Dodge Chance</span>: +0.05% per point</p>
                    <p>‚Ä¢ <span class="stat-contribution">Speed</span>: +0.5 per point</p>
                    <p style="margin-top: 8px; color: var(--text-accent);"><strong>Best for:</strong> Mages, support builds</p>
                `,
                charisma: `
                    <h4>Charisma</h4>
                    <p><strong>Current Value:</strong> <span class="stat-value">${totalValue}</span></p>
                    <p><strong>Affects:</strong></p>
                    <p>‚Ä¢ <span class="stat-contribution">Status Effect Power</span>: Increases buff/debuff strength</p>
                    <p>‚Ä¢ <span class="stat-contribution">Buff Duration</span>: Extends buff duration</p>
                    <p>‚Ä¢ <span class="stat-contribution">Debuff Resistance</span>: Reduces chance to be debuffed</p>
                    <p style="margin-top: 8px; color: var(--text-accent);"><strong>Best for:</strong> Support builds, status effect builds</p>
                `
            };
            return tooltips[stat] || '';
        }

        function getCombatStatTooltip(stat, value, baseStats) {
            const might = baseStats.might || 0;
            const agility = baseStats.agility || 0;
            const vitality = baseStats.vitality || 0;
            const intellect = baseStats.intellect || 0;
            const wisdom = baseStats.wisdom || 0;
            const charisma = baseStats.charisma || 0;

            const tooltips = {
                attack_power: `
                    <h4>Attack Power</h4>
                    <p><strong>Current Value:</strong> <span class="stat-value">${Math.floor(value)}</span></p>
                    <p><strong>Calculation:</strong></p>
                    <p>Might √ó 2 + Agility √ó 1 + Intellect √ó 0.5</p>
                    <p>= ${might} √ó 2 + ${agility} √ó 1 + ${intellect} √ó 0.5</p>
                    <p>= ${(might * 2)} + ${agility} + ${(intellect * 0.5).toFixed(1)}</p>
                    <p style="margin-top: 8px;"><strong>Used for:</strong> Physical damage from melee and ranged weapons</p>
                `,
                defense: `
                    <h4>Defense</h4>
                    <p><strong>Current Value:</strong> <span class="stat-value">${Math.floor(value)}</span></p>
                    <p><strong>Calculation:</strong></p>
                    <p>Vitality √ó 2 + Might √ó 0.5</p>
                    <p>= ${vitality} √ó 2 + ${might} √ó 0.5</p>
                    <p>= ${(vitality * 2)} + ${(might * 0.5).toFixed(1)}</p>
                    <p style="margin-top: 8px;"><strong>Effect:</strong> Reduces incoming physical damage. Higher defense = less damage taken.</p>
                `,
                crit_chance: `
                    <h4>Critical Hit Chance</h4>
                    <p><strong>Current Value:</strong> <span class="stat-value">${(value * 100).toFixed(2)}%</span></p>
                    <p><strong>Calculation:</strong></p>
                    <p>Agility √ó 0.001 + Intellect √ó 0.0005 (max 50%)</p>
                    <p>= ${agility} √ó 0.001 + ${intellect} √ó 0.0005</p>
                    <p>= ${(agility * 0.001).toFixed(3)} + ${(intellect * 0.0005).toFixed(3)}</p>
                    <p style="margin-top: 8px;"><strong>Effect:</strong> Chance to deal 2x damage on hit</p>
                `,
                dodge_chance: `
                    <h4>Dodge Chance</h4>
                    <p><strong>Current Value:</strong> <span class="stat-value">${(value * 100).toFixed(2)}%</span></p>
                    <p><strong>Calculation:</strong></p>
                    <p>Agility √ó 0.0015 + Wisdom √ó 0.0005 (max 25%)</p>
                    <p>= ${agility} √ó 0.0015 + ${wisdom} √ó 0.0005</p>
                    <p>= ${(agility * 0.0015).toFixed(3)} + ${(wisdom * 0.0005).toFixed(3)}</p>
                    <p style="margin-top: 8px;"><strong>Effect:</strong> Completely avoid an attack. Checked before parry.</p>
                `,
                parry_chance: `
                    <h4>Parry Chance</h4>
                    <p><strong>Current Value:</strong> <span class="stat-value">${(value * 100).toFixed(2)}%</span></p>
                    <p><strong>Calculation:</strong></p>
                    <p>Might √ó 0.001 + Vitality √ó 0.0005 (max 15%)</p>
                    <p>= ${might} √ó 0.001 + ${vitality} √ó 0.0005</p>
                    <p>= ${(might * 0.001).toFixed(3)} + ${(vitality * 0.0005).toFixed(3)}</p>
                    <p style="margin-top: 8px;"><strong>Effect:</strong> Block an attack completely. Checked after dodge.</p>
                `,
                speed: `
                    <h4>Speed</h4>
                    <p><strong>Current Value:</strong> <span class="stat-value">${Math.floor(value)}</span></p>
                    <p><strong>Calculation:</strong></p>
                    <p>Agility √ó 1 + Wisdom √ó 0.5</p>
                    <p>= ${agility} √ó 1 + ${wisdom} √ó 0.5</p>
                    <p>= ${agility} + ${(wisdom * 0.5).toFixed(1)}</p>
                    <p style="margin-top: 8px;"><strong>Effect:</strong> Affects turn order and movement</p>
                `,
                spell_power: `
                    <h4>Spell Power</h4>
                    <p><strong>Current Value:</strong> <span class="stat-value">${Math.floor(value)}</span></p>
                    <p><strong>Calculation:</strong></p>
                    <p>Intellect √ó 2 + Wisdom √ó 1</p>
                    <p>= ${intellect} √ó 2 + ${wisdom} √ó 1</p>
                    <p>= ${(intellect * 2)} + ${wisdom}</p>
                    <p style="margin-top: 8px;"><strong>Used for:</strong> Magical damage from staffs and wands</p>
                `,
                max_hp: `
                    <h4>Maximum HP</h4>
                    <p><strong>Current Value:</strong> <span class="stat-value">${Math.floor(value)}</span></p>
                    <p><strong>Calculation:</strong></p>
                    <p>Base 100 + Might √ó 2 + Vitality √ó 6</p>
                    <p>= 100 + ${might} √ó 2 + ${vitality} √ó 6</p>
                    <p>= 100 + ${(might * 2)} + ${(vitality * 6)}</p>
                    <p style="margin-top: 8px;"><strong>Effect:</strong> Your maximum health points</p>
                `,
                max_mana: `
                    <h4>Maximum Mana</h4>
                    <p><strong>Current Value:</strong> <span class="stat-value">${Math.floor(value)}</span></p>
                    <p><strong>Calculation:</strong></p>
                    <p>Base 50 + Intellect √ó 3 + Wisdom √ó 2</p>
                    <p>= 50 + ${intellect} √ó 3 + ${wisdom} √ó 2</p>
                    <p>= 50 + ${(intellect * 3)} + ${(wisdom * 2)}</p>
                    <p style="margin-top: 8px;"><strong>Effect:</strong> Used to cast abilities. Regenerates over time based on Wisdom.</p>
                `,
                mana_regen_per_second: `
                    <h4>Mana Regeneration</h4>
                    <p><strong>Current Value:</strong> <span class="stat-value">${value.toFixed(2)}/s</span></p>
                    <p><strong>Calculation:</strong></p>
                    <p>Base 1.0 + Wisdom √ó 0.1</p>
                    <p>= 1.0 + ${wisdom} √ó 0.1</p>
                    <p>= ${(1.0 + wisdom * 0.1).toFixed(2)} mana per second</p>
                    <p style="margin-top: 8px;"><strong>Effect:</strong> Mana regenerates continuously during combat. Higher Wisdom means faster mana recovery.</p>
                `
            };
            return tooltips[stat] || '';
        }

        function getItemIconPath(slot, weaponType, rarity) {
            // Weapon icons
            if (slot === 'main_hand' && weaponType) {
                const weaponMap = {
                    'sword': 'weapon_sword.png',
                    'bow': 'weapon_bow.PNG',
                    'staff': 'weapon_staff.png',
                    'mace': 'weapon_mace.PNG',
                    'dagger': 'weapon_knife.PNG',
                    'wand': 'weapon_staff.png' // Use staff icon for wand
                };
                const iconFile = weaponMap[weaponType] || 'weapon_sword.png';
                return `/assets/weapons/${iconFile}`;
            }
            
            if (slot === 'off_hand') {
                return '/assets/weapons/weapon_shield.PNG';
            }
            
            // Armor icons - try to determine armor type from rarity or use default
            const armorMap = {
                'helmet': 'metal_helmet.PNG',
                'chest': 'metal_armor.png',
                'legs': 'metal_pants.png',
                'boots': 'metal_boots.png',
                'gloves': 'metal_gloves.PNG'
            };
            
            if (armorMap[slot]) {
                return `/assets/armor/${armorMap[slot]}`;
            }
            
            // Default fallback
            return '/assets/weapons/weapon_sword.png';
        }

        function getWeaponTooltip(weaponType) {
            const weaponInfo = {
                'sword': {
                    name: 'Sword',
                    damage: 'Physical',
                    speed: '2.0s',
                    abilities: [
                        {name: 'Power Strike', desc: 'Deal 1.5x physical damage', cooldown: '5s'},
                        {name: 'Cleave', desc: 'Deal 1.3x physical damage', cooldown: '8s'},
                        {name: 'Whirlwind', desc: 'Deal 2.0x AOE physical damage', cooldown: '15s', ultimate: true}
                    ],
                    recommended: 'Might (primary), Vitality (defense), Agility (crit/dodge)',
                    playstyle: 'Balanced melee fighter with good damage and survivability'
                },
                'staff': {
                    name: 'Staff',
                    damage: 'Magical',
                    speed: '2.5s',
                    abilities: [
                        {name: 'Magic Bolt', desc: 'Deal 1.5x magical damage', cooldown: '5s'},
                        {name: 'Fireball', desc: 'Deal 1.8x magical damage', cooldown: '8s'},
                        {name: 'Meteor', desc: 'Deal 3.0x high magical damage', cooldown: '20s', ultimate: true}
                    ],
                    recommended: 'Intellect (primary), Wisdom (mana regen, magic resist), Vitality (survivability)',
                    playstyle: 'Spellcaster with high magical damage. Mana management is important.'
                },
                'bow': {
                    name: 'Bow',
                    damage: 'Physical',
                    speed: '1.8s',
                    abilities: [
                        {name: 'Quick Shot', desc: 'Deal 1.3x physical damage', cooldown: '4s'},
                        {name: 'Piercing Arrow', desc: 'Deal 1.6x physical damage, ignores some defense', cooldown: '7s'},
                        {name: 'Barrage', desc: 'Deal 2.5x multi-hit physical damage', cooldown: '18s', ultimate: true}
                    ],
                    recommended: 'Agility (primary), Might (damage), Wisdom (dodge)',
                    playstyle: 'Fast ranged attacker with high crit and dodge potential'
                },
                'dagger': {
                    name: 'Dagger',
                    damage: 'Physical',
                    speed: '1.5s',
                    abilities: [
                        {name: 'Backstab', desc: 'Deal 1.4x physical damage, high crit chance', cooldown: '4s'},
                        {name: 'Poison Strike', desc: 'Deal 1.2x physical damage over time', cooldown: '6s'},
                        {name: 'Assassinate', desc: 'Deal 3.5x physical damage, guaranteed crit', cooldown: '12s', ultimate: true}
                    ],
                    recommended: 'Agility (primary), Might (damage), Intellect (utility)',
                    playstyle: 'Fast melee attacker with high crit chance and burst damage'
                },
                'mace': {
                    name: 'Mace',
                    damage: 'Physical',
                    speed: '2.3s',
                    abilities: [
                        {name: 'Crush', desc: 'Deal 1.5x physical damage', cooldown: '6s'},
                        {name: 'Stun Strike', desc: 'Deal 1.3x physical damage, chance to stun', cooldown: '9s'},
                        {name: 'Devastate', desc: 'Deal 2.8x physical damage, reduces enemy armor', cooldown: '16s', ultimate: true}
                    ],
                    recommended: 'Might (primary), Vitality (tankiness), Wisdom (utility)',
                    playstyle: 'Slower but hard-hitting weapon, good for tank builds'
                },
                'wand': {
                    name: 'Wand',
                    damage: 'Magical',
                    speed: '2.0s',
                    abilities: [
                        {name: 'Arcane Missile', desc: 'Deal 1.5x magical damage', cooldown: '5s'},
                        {name: 'Chain Lightning', desc: 'Deal 1.7x magical damage, chains to nearby enemies', cooldown: '8s'},
                        {name: 'Arcane Storm', desc: 'Deal 2.8x AOE magical damage', cooldown: '18s', ultimate: true}
                    ],
                    recommended: 'Intellect (primary), Wisdom (mana regen), Agility (speed)',
                    playstyle: 'Faster spellcaster than staff, good for hybrid builds'
                }
            };
            
            const info = weaponInfo[weaponType];
            if (!info) return '';
            
            let abilitiesHtml = '<p><strong>Abilities:</strong></p>';
            info.abilities.forEach(ability => {
                const ultimateBadge = ability.ultimate ? ' <span style="color: var(--warning);">(Ultimate)</span>' : '';
                abilitiesHtml += `<p>‚Ä¢ <span class="stat-contribution">${ability.name}</span>${ultimateBadge}: ${ability.desc} (${ability.cooldown})</p>`;
            });
            
            return `
                <h4>${info.name}</h4>
                <p><strong>Damage Type:</strong> <span class="stat-value">${info.damage}</span></p>
                <p><strong>Attack Speed:</strong> <span class="stat-value">${info.speed}</span></p>
                ${abilitiesHtml}
                <p style="margin-top: 8px;"><strong>Recommended Stats:</strong></p>
                <p style="color: var(--text-accent);">${info.recommended}</p>
                <p style="margin-top: 8px; color: var(--text-secondary);"><em>${info.playstyle}</em></p>
            `;
        }

        function updateSkillsScreen() {
            // Reset skill allocation to current stats
            skillAllocation = {...characterData.stats};
            
            const allocationEl = document.getElementById('skill-allocation');
            allocationEl.innerHTML = '';

            const statNames = {
                might: 'Might',
                agility: 'Agility',
                vitality: 'Vitality',
                intellect: 'Intellect',
                wisdom: 'Wisdom',
                charisma: 'Charisma'
            };

            for (const [stat, name] of Object.entries(statNames)) {
                const panel = document.createElement('div');
                panel.className = 'skill-panel';
                panel.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="margin: 0;">${name}</h3>
                        <button class="combat-action-btn" onclick="showSkillInfo('${stat}')" style="padding: 3px 8px; font-size: 0.75em; min-width: auto;">More Info</button>
                    </div>
                    <div class="skill-controls">
                        <button class="skill-btn decrease" onclick="adjustSkill('${stat}', -1)">-</button>
                        <div class="skill-value" id="skill-${stat}">${skillAllocation[stat] || 0}</div>
                        <button class="skill-btn increase" onclick="adjustSkill('${stat}', 1)">+</button>
                    </div>
                `;
                allocationEl.appendChild(panel);
            }

            updateSkillPointsDisplay();
        }

        function showSkillInfo(stat) {
            const description = getStatDescription(stat);
            if (description) {
                const modal = document.getElementById('skill-info-modal');
                const content = document.getElementById('skill-info-content');
                const statName = stat.charAt(0).toUpperCase() + stat.slice(1);
                content.innerHTML = `<h2>${statName} Information</h2><div style="line-height: 1.8; color: var(--text-primary);">${description}</div>`;
                modal.classList.add('active');
            }
        }

        function closeSkillInfoModal() {
            const modal = document.getElementById('skill-info-modal');
            modal.classList.remove('active');
        }

        // Close skill info modal on ESC key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const skillModal = document.getElementById('skill-info-modal');
                if (skillModal && skillModal.classList.contains('active')) {
                    closeSkillInfoModal();
                }
            }
        });

        function getStatDescription(stat) {
            const descriptions = {
                might: `
                    <div style="line-height: 1.8;">
                        <p><strong>Increases melee physical damage:</strong> +2 Attack Power per point. Attack Power is used for all physical damage from melee and ranged weapons.</p>
                        <p><strong>Increases maximum HP:</strong> +2 HP per point. Higher HP means you can survive more damage before being defeated.</p>
                        <p><strong>Increases Parry chance:</strong> +0.1% per point (maximum 15%). Parrying completely blocks an attack, taking no damage. Parry is checked after dodge but before damage calculation.</p>
                        <p><strong>Increases Defense:</strong> +0.5 Defense per point. Defense reduces incoming physical damage through diminishing returns formula.</p>
                        <p style="margin-top: 10px; color: var(--text-accent);"><strong>Best for:</strong> Melee fighters, tanks, characters who want to deal physical damage and survive longer.</p>
                    </div>
                `,
                agility: `
                    <div style="line-height: 1.8;">
                        <p><strong>Increases attack speed:</strong> Affects weapon attack speed. Higher agility means you attack more frequently.</p>
                        <p><strong>Increases Dodge chance:</strong> +0.15% per point (maximum 25%). Dodging completely avoids an attack, taking no damage. Dodge is checked before parry.</p>
                        <p><strong>Increases Critical Hit chance:</strong> +0.1% per point (maximum 50%). Critical hits deal 2x damage. Higher crit chance means more frequent critical hits.</p>
                        <p><strong>Increases ranged physical damage:</strong> +1 Attack Power per point. Works well with bows and other ranged weapons.</p>
                        <p><strong>Increases Speed:</strong> +1 Speed per point. Speed affects turn order and movement in combat.</p>
                        <p style="margin-top: 10px; color: var(--text-accent);"><strong>Best for:</strong> Rangers, rogues, fast attackers who want to dodge attacks and deal critical hits.</p>
                    </div>
                `,
                vitality: `
                    <div style="line-height: 1.8;">
                        <p><strong>Increases maximum HP:</strong> +6 HP per point. This is the largest HP contribution per stat point, making Vitality essential for survivability.</p>
                        <p><strong>Increases Defense:</strong> +2 Defense per point. Defense reduces incoming physical damage. Higher defense means less damage taken from physical attacks.</p>
                        <p><strong>Increases Parry chance:</strong> +0.05% per point. Parrying blocks an attack completely, taking no damage.</p>
                        <p><strong>Increases Magic Resistance:</strong> +0.25 per point. Magic Resistance reduces incoming magical damage from spells and magical weapons.</p>
                        <p style="margin-top: 10px; color: var(--text-accent);"><strong>Best for:</strong> Tanks, characters focused on survivability, anyone who wants to take less damage.</p>
                    </div>
                `,
                intellect: `
                    <div style="line-height: 1.8;">
                        <p><strong>Increases Spell Power:</strong> +2 Spell Power per point. Spell Power is used for magical damage from staffs and wands. This is the primary stat for mages.</p>
                        <p><strong>Increases maximum Mana:</strong> +3 Mana per point. Mana is consumed when using abilities. Higher max mana means you can use more abilities before running out.</p>
                        <p><strong>Increases Critical Hit chance for spells:</strong> +0.05% per point. Critical hits deal 2x damage. This applies specifically to magical damage.</p>
                        <p><strong>Increases Attack Power:</strong> +0.5 Attack Power per point. Provides minor contribution to physical damage.</p>
                        <p style="margin-top: 10px; color: var(--text-accent);"><strong>Best for:</strong> Mages, spellcasters, characters using staffs or wands for magical damage.</p>
                    </div>
                `,
                wisdom: `
                    <div style="line-height: 1.8;">
                        <p><strong>Increases Mana regeneration rate:</strong> +0.1 mana per second per point in combat. Mana regenerates over time, allowing you to use abilities more frequently. Higher Wisdom means faster mana recovery.</p>
                        <p><strong>Increases Spell Power:</strong> +1 Spell Power per point. Contributes to magical damage, though less than Intellect.</p>
                        <p><strong>Increases Magic Resistance:</strong> +0.5 per point. Magic Resistance reduces incoming magical damage. Higher resistance means less damage taken from spells and magical weapons.</p>
                        <p><strong>Increases Dodge chance:</strong> +0.05% per point. Provides minor contribution to dodge chance.</p>
                        <p><strong>Increases Speed:</strong> +0.5 Speed per point. Affects turn order and movement.</p>
                        <p style="margin-top: 10px; color: var(--text-accent);"><strong>Best for:</strong> Mages, support builds, characters who need mana regeneration and magic resistance.</p>
                    </div>
                `,
                charisma: `
                    <div style="line-height: 1.8;">
                        <p><strong>Increases Status Effect Power:</strong> Makes your buffs and debuffs more powerful. Higher Charisma means your status effects have greater impact on targets.</p>
                        <p><strong>Increases Buff Duration:</strong> Extends how long your beneficial buffs last. This allows you to maintain powerful effects longer in combat.</p>
                        <p><strong>Increases Debuff Resistance:</strong> Reduces the chance that enemy debuffs will affect you. Higher Charisma makes you more resistant to negative status effects.</p>
                        <p style="margin-top: 10px;"><strong>Status Effects:</strong> Buffs enhance your abilities (e.g., damage boost, defense boost), while debuffs weaken enemies (e.g., poison, slow, stun). Charisma makes your effects more powerful and harder to resist.</p>
                        <p style="margin-top: 10px; color: var(--text-accent);"><strong>Best for:</strong> Support builds, status effect builds, characters who want to control combat through buffs and debuffs.</p>
                    </div>
                `
            };
            return descriptions[stat] || '';
        }

        function adjustSkill(stat, change) {
            const current = skillAllocation[stat] || 0;
            const newValue = current + change;
            
            if (newValue < 1 || newValue > 100) return;
            
            // Check available points
            const totalAllocated = Object.values(skillAllocation).reduce((sum, val) => sum + (val || 0), 0);
            const basePoints = 6 * 10; // Starting 10 in each
            const pointsUsed = totalAllocated - basePoints;
            const availablePoints = characterData.skill_points;
            
            const newPointsUsed = (totalAllocated - current + newValue) - basePoints;
            if (newPointsUsed > pointsUsed + availablePoints) return;
            
            skillAllocation[stat] = newValue;
            document.getElementById(`skill-${stat}`).textContent = newValue;
            updateSkillPointsDisplay();
        }

        function updateSkillPointsDisplay() {
            const totalAllocated = Object.values(skillAllocation).reduce((sum, val) => sum + (val || 0), 0);
            const basePoints = 6 * 10;
            const pointsUsed = totalAllocated - basePoints;
            const available = characterData.skill_points - (pointsUsed - (Object.values(characterData.stats).reduce((sum, val) => sum + val, 0) - basePoints));
            
            document.getElementById('available-points').textContent = Math.max(0, available);
        }

        async function saveSkills() {
            if (!currentCharacterId) return;

            try {
                const response = await authenticatedFetch(`/api/character/${currentCharacterId}/skills`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ stats: skillAllocation })
                });

                const result = await response.json();
                
                if (result.success) {
                    await refreshCharacterData();
                    alert('Skills saved successfully!');
                } else {
                    alert('Error saving skills: ' + (result.detail || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error saving skills:', error);
                alert('Error saving skills');
            }
        }

        function updateInventoryScreen() {
            const inventoryGrid = document.getElementById('inventory-grid');
            inventoryGrid.innerHTML = '';

            let filteredItems = characterData.inventory || [];
            
            if (currentInventoryFilter !== 'all') {
                filteredItems = filteredItems.filter(item => item.rarity === currentInventoryFilter);
            }

            if (filteredItems.length === 0) {
                inventoryGrid.innerHTML = '<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">No items in inventory</p>';
                return;
            }

            for (const item of filteredItems) {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'inventory-item';
                
                const statsText = Object.entries(item.stats || {})
                    .map(([stat, val]) => `${stat}: +${val}`)
                    .join(', ');

                const iconPath = getItemIconPath(item.slot, item.weapon_type, item.rarity);
                const weaponTooltip = item.weapon_type ? getWeaponTooltip(item.weapon_type) : '';
                itemDiv.className = 'inventory-item tooltip-container';
                itemDiv.innerHTML = `
                    <img src="${iconPath}" alt="${item.name}" class="inventory-item-icon" onerror="this.style.display='none';">
                    <div class="item-rarity rarity-${item.rarity}">${item.rarity.toUpperCase()}</div>
                    <div class="item-name">${item.name}</div>
                    <div class="item-stats">${statsText}</div>
                    <div class="item-actions">
                        <button class="item-action-btn equip-btn" onclick="equipItem('${item.id}', '${item.slot}')">Equip</button>
                        <button class="item-action-btn" onclick="sellItem('${item.id}')" style="background: var(--danger); margin-left: 5px;">Sell</button>
                        <button class="item-action-btn" onclick="upgradeItem('${item.id}')" style="background: var(--accent-secondary); margin-left: 5px; font-size: 0.85em;">Upgrade</button>
                        <button class="item-action-btn" onclick="rerollItem('${item.id}')" style="background: var(--accent-tertiary); margin-left: 5px; font-size: 0.85em;">Re-roll</button>
                    </div>
                    ${weaponTooltip ? `<div class="tooltip" style="min-width: 300px;">${weaponTooltip}</div>` : ''}
                `;
                
                inventoryGrid.appendChild(itemDiv);
            }
        }

        function filterInventory(rarity) {
            currentInventoryFilter = rarity;
            
            // Update filter buttons
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            updateInventoryScreen();
        }

        async function equipItem(itemId, slot) {
            if (!currentCharacterId) return;

            try {
                const response = await authenticatedFetch(`/api/equipment/equip`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        character_id: currentCharacterId,
                        item_id: itemId,
                        slot: slot
                    })
                });

                const result = await response.json();
                
                if (result.success) {
                    await refreshCharacterData();
                } else {
                    alert('Error equipping item: ' + (result.detail || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error equipping item:', error);
                alert('Error equipping item');
            }
        }

        async function sellItem(itemId) {
            if (!currentCharacterId) return;

            if (!confirm('Are you sure you want to sell this item?')) {
                return;
            }

            try {
                const response = await authenticatedFetch(`/api/store/sell`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        character_id: currentCharacterId,
                        item_id: itemId
                    })
                });

                const result = await response.json();
                
                if (result.success) {
                    await refreshCharacterData();
                    alert(`Item sold for ${result.gold_gained} gold!`);
                } else {
                    alert('Error selling item: ' + (result.detail || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error selling item:', error);
                alert('Error selling item');
            }
        }

        async function upgradeItem(itemId) {
            if (!currentCharacterId) return;

            try {
                const response = await authenticatedFetch(`/api/equipment/upgrade`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        character_id: currentCharacterId,
                        item_id: itemId
                    })
                });

                const result = await response.json();
                
                if (result.success) {
                    await refreshCharacterData();
                    alert(`Item upgraded! Gold spent: ${result.gold_spent}, Remaining: ${result.gold_remaining}`);
                } else {
                    alert('Error upgrading item: ' + (result.detail || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error upgrading item:', error);
                alert('Error upgrading item');
            }
        }

        async function rerollItem(itemId) {
            if (!currentCharacterId) return;

            if (!confirm('Re-roll this item\'s stats? This will randomly regenerate all stats.')) {
                return;
            }

            try {
                const response = await authenticatedFetch(`/api/equipment/reroll`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        character_id: currentCharacterId,
                        item_id: itemId
                    })
                });

                const result = await response.json();
                
                if (result.success) {
                    await refreshCharacterData();
                    alert(`Item stats re-rolled! Gold spent: ${result.gold_spent}, Remaining: ${result.gold_remaining}`);
                } else {
                    alert('Error re-rolling item: ' + (result.detail || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error re-rolling item:', error);
                alert('Error re-rolling item');
            }
        }

        async function resetSkillPoints() {
            if (!currentCharacterId) return;

            const charLevel = characterData.level || 1;
            const cost = 5000 + (charLevel * 200);

            if (!confirm(`Reset all skill points? This will refund all skill points and reset stats to base values.\n\nCost: ${cost} gold`)) {
                return;
            }

            try {
                const response = await authenticatedFetch(`/api/character/respec`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        character_id: currentCharacterId
                    })
                });

                const result = await response.json();
                
                if (result.success) {
                    await refreshCharacterData();
                    alert(`Skills reset! Refunded ${result.refunded_skill_points} skill points. Gold spent: ${result.gold_spent}, Remaining: ${result.gold_remaining}`);
                } else {
                    alert('Error resetting skills: ' + (result.detail || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error resetting skills:', error);
                alert('Error resetting skills');
            }
        }

        // Combat functions
        async function loadPvEEnemies() {
            if (!currentCharacterId) return;
            
            try {
                const response = await fetch(`/api/pve/list?character_id=${currentCharacterId}`);
                const result = await response.json();
                
                if (result.success) {
                    const listEl = document.getElementById('pve-enemy-list');
                    listEl.innerHTML = '';
                    
                    if (result.enemies.length === 0) {
                        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">No enemies available</p>';
                        return;
                    }
                    
                    for (const enemy of result.enemies) {
                        const enemyDiv = document.createElement('div');
                        enemyDiv.style.cssText = 'padding: 10px; margin: 5px 0; border: 1px solid var(--border-color); border-radius: 8px; cursor: pointer; transition: all 0.2s;';
                        if (!enemy.unlocked) {
                            enemyDiv.style.opacity = '0.5';
                            enemyDiv.style.cursor = 'not-allowed';
                        } else {
                            enemyDiv.style.cursor = 'pointer';
                            enemyDiv.onmouseover = () => enemyDiv.style.background = 'var(--bg-card-hover)';
                            enemyDiv.onmouseout = () => enemyDiv.style.background = 'transparent';
                            enemyDiv.onclick = () => startCombat(enemy.id, false);
                        }
                        
                        enemyDiv.innerHTML = `
                            <div style="font-weight: 600;">${enemy.name}</div>
                            <div style="font-size: 0.9em; color: var(--text-secondary);">Level ${enemy.level} ${enemy.unlocked ? '' : '(Locked)'}</div>
                            ${enemy.description ? `<div style="font-size: 0.85em; color: var(--text-secondary); margin-top: 5px; font-style: italic;">${enemy.description}</div>` : ''}
                            <div style="font-size: 0.85em; color: var(--text-accent); margin-top: 5px;">
                                Reward: ${enemy.gold_min}-${enemy.gold_max}g | Drop: ${enemy.drop_chance}%
                            </div>
                            ${enemy.unlocked ? `
                                <div style="display: flex; gap: 5px; margin-top: 10px;">
                                    <button class="combat-action-btn" onclick="event.stopPropagation(); startCombat('${enemy.id}', false);" style="flex: 1; font-size: 0.9em; padding: 8px;">Fight</button>
                                    <button class="combat-action-btn" onclick="event.stopPropagation(); startAutoFight('${enemy.id}');" style="flex: 1; font-size: 0.9em; padding: 8px;">Auto-Fight (1 Hour)</button>
                                </div>
                            ` : ''}
                        `;
                        
                        listEl.appendChild(enemyDiv);
                    }
                }
            } catch (error) {
                console.error('Error loading PvE enemies:', error);
            }
        }
        
        async function loadLeaderboard() {
            try {
                const response = await authenticatedFetch('/api/pvp/leaderboard?limit=100');
                const result = await response.json();
                
                if (result.success) {
                    const leaderboardContent = document.getElementById('leaderboard-content');
                    leaderboardContent.innerHTML = '';
                    
                    if (result.leaderboard.length === 0) {
                        leaderboardContent.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">No players on leaderboard yet.</p>';
                        return;
                    }
                    
                    // Create table header
                    const table = document.createElement('table');
                    table.style.width = '100%';
                    table.style.borderCollapse = 'collapse';
                    table.style.marginTop = '10px';
                    
                    const thead = document.createElement('thead');
                    thead.innerHTML = `
                        <tr style="background: var(--bg-tertiary); border-bottom: 2px solid var(--border-color);">
                            <th style="padding: 10px; text-align: left;">Rank</th>
                            <th style="padding: 10px; text-align: left;">Name</th>
                            <th style="padding: 10px; text-align: left;">Level</th>
                            <th style="padding: 10px; text-align: left;">MMR</th>
                            <th style="padding: 10px; text-align: left;">Wins</th>
                            <th style="padding: 10px; text-align: left;">Losses</th>
                            <th style="padding: 10px; text-align: left;">Win Rate</th>
                        </tr>
                    `;
                    table.appendChild(thead);
                    
                    const tbody = document.createElement('tbody');
                    result.leaderboard.forEach((player) => {
                        const row = document.createElement('tr');
                        row.style.borderBottom = '1px solid var(--border-color)';
                        if (player.id === currentCharacterId) {
                            row.style.background = 'rgba(99, 102, 241, 0.2)';
                            row.style.fontWeight = '600';
                        }
                        row.innerHTML = `
                            <td style="padding: 10px;">${player.rank}</td>
                            <td style="padding: 10px;">${player.name}</td>
                            <td style="padding: 10px;">${player.level}</td>
                            <td style="padding: 10px; color: var(--text-accent);">${player.mmr}</td>
                            <td style="padding: 10px; color: var(--success);">${player.wins}</td>
                            <td style="padding: 10px; color: var(--danger);">${player.losses}</td>
                            <td style="padding: 10px;">${player.win_rate}%</td>
                        `;
                        tbody.appendChild(row);
                        
                        // Update player's rank if this is their character
                        if (player.id === currentCharacterId) {
                            document.getElementById('pvp-rank-display').textContent = `#${player.rank}`;
                        }
                    });
                    table.appendChild(tbody);
                    leaderboardContent.appendChild(table);
                }
            } catch (error) {
                console.error('Error loading leaderboard:', error);
                document.getElementById('leaderboard-content').innerHTML = '<p style="text-align: center; color: var(--danger);">Error loading leaderboard.</p>';
            }
        }
        
        async function loadPvPOpponents() {
            try {
                const response = await fetch('/api/pvp/available');
                const result = await response.json();
                
                if (result.success) {
                    const listEl = document.getElementById('pvp-opponent-list');
                    listEl.innerHTML = '';
                    
                    if (result.players.length === 0) {
                        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">No opponents available</p>';
                        return;
                    }
                    
                    for (const player of result.players) {
                        const playerDiv = document.createElement('div');
                        playerDiv.style.cssText = 'padding: 10px; margin: 5px 0; border: 1px solid var(--border-color); border-radius: 8px; cursor: pointer; transition: all 0.2s;';
                        playerDiv.onmouseover = () => playerDiv.style.background = 'var(--bg-card-hover)';
                        playerDiv.onmouseout = () => playerDiv.style.background = 'transparent';
                        playerDiv.onclick = () => startCombat(player.id, true);
                        
                        playerDiv.innerHTML = `
                            <div style="font-weight: 600;">${player.name}</div>
                            <div style="font-size: 0.9em; color: var(--text-secondary);">Level ${player.level}</div>
                        `;
                        
                        listEl.appendChild(playerDiv);
                    }
                }
            } catch (error) {
                console.error('Error loading PvP opponents:', error);
            }
        }
        
        async function startCombat(opponentId, isPvP) {
            if (!currentCharacterId) return;
            
            try {
                const requestBody = {
                    character_id: currentCharacterId,
                    is_pvp: isPvP
                };
                
                if (isPvP) {
                    requestBody.opponent_id = opponentId;
                } else {
                    requestBody.enemy_id = opponentId;
                }
                
                const response = await authenticatedFetch('/api/combat/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    let errorDetail = 'Unknown error';
                    try {
                        const errorJson = JSON.parse(errorText);
                        errorDetail = errorJson.detail || errorJson.message || errorText;
                    } catch (e) {
                        errorDetail = errorText || `HTTP ${response.status}`;
                    }
                    alert('Error starting combat: ' + errorDetail);
                    console.error('Combat start error:', response.status, errorDetail);
                    return;
                }
                
                const result = await response.json();
                
                if (result.success) {
                    currentCombatId = result.combat_id;
                    showActiveCombat();
                    startCombatPolling();
                    loadAbilities();
                } else {
                    alert('Error starting combat: ' + (result.detail || 'Unknown error'));
                    console.error('Combat start failed:', result);
                }
            } catch (error) {
                console.error('Error starting combat:', error);
                alert('Error starting combat');
            }
        }
        
        function showActiveCombat() {
            document.getElementById('combat-selection').style.display = 'none';
            document.getElementById('active-combat').style.display = 'block';
            
            // Initialize stance selector
            if (characterData && characterData.combat_stance) {
                const stanceSelect = document.getElementById('combat-stance-select');
                if (stanceSelect) {
                    stanceSelect.value = characterData.combat_stance;
                }
            }
        }
        
        function hideActiveCombat() {
            document.getElementById('combat-selection').style.display = 'block';
            document.getElementById('active-combat').style.display = 'none';
        }
        
        function startCombatPolling() {
            if (combatPollInterval) {
                clearInterval(combatPollInterval);
            }
            
            combatPollInterval = setInterval(async () => {
                if (!currentCombatId) return;
                
                try {
                    const response = await authenticatedFetch(`/api/combat/state/${currentCombatId}`);
                const result = await response.json();
                
                if (result.success) {
                    updateCombatDisplay(result.combat);
                    
                    // Process visual events for animations
                    if (result.visual_events && result.visual_events.length > 0) {
                        console.log('Received visual events:', result.visual_events);
                        processVisualEvents(result.visual_events);
                    } else {
                        // Debug: log when no events are received
                        if (result.combat && result.combat.is_active) {
                            console.log('Combat active but no visual events received');
                        }
                    }
                    
                    if (!result.combat.is_active) {
                            clearInterval(combatPollInterval);
                            combatPollInterval = null;
                            
                            // Show rewards
                            if (result.combat.rewards) {
                                alert(`Victory! Gained ${result.combat.rewards.exp_gained} EXP and ${result.combat.rewards.gold_gained} gold!`);
                                await refreshCharacterData();
                                
                                // Unlock next enemy if PvE
                                if (!result.combat.is_pvp && result.combat.winner_id === currentCharacterId) {
                                    try {
                                        await authenticatedFetch('/api/pve/unlock', {
                                            method: 'POST',
                                            headers: { 'Content-Type': 'application/json' },
                                            body: JSON.stringify({
                                                character_id: currentCharacterId,
                                                enemy_id: result.combat.character2_id
                                            })
                                        });
                                        loadPvEEnemies();
                                    } catch (error) {
                                        console.error('Error unlocking enemy:', error);
                                    }
                                }
                            }
                            
                            setTimeout(() => {
                                hideActiveCombat();
                                currentCombatId = null;
                            }, 3000);
                        }
                    }
                } catch (error) {
                    console.error('Error polling combat state:', error);
                }
            }, 500);
        }
        
        function updateStatusEffects(containerId, buffs, debuffs) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            container.innerHTML = '';
            
            // Add buff icons
            for (const [buffId, buffData] of Object.entries(buffs || {})) {
                const buffEl = document.createElement('div');
                buffEl.className = 'status-effect buff';
                buffEl.title = buffData.type || buffId;
                buffEl.textContent = '‚Üë';
                container.appendChild(buffEl);
            }
            
            // Add debuff icons
            for (const [debuffId, debuffData] of Object.entries(debuffs || {})) {
                const debuffEl = document.createElement('div');
                debuffEl.className = 'status-effect debuff';
                debuffEl.title = debuffData.type || debuffId;
                debuffEl.textContent = '‚Üì';
                container.appendChild(debuffEl);
            }
        }
        
        function updateCombatDisplay(combat) {
            const player1 = combat.player1;
            const player2 = combat.player2;
            
            // Update player info
            document.getElementById('player-combat-name').textContent = player1.name;
            const playerHpPercent = (player1.current_hp / player1.max_hp) * 100;
            document.getElementById('player-hp-fill').style.width = playerHpPercent + '%';
            document.getElementById('player-hp-text').textContent = `${Math.max(0, Math.floor(player1.current_hp))}/${player1.max_hp}`;
            document.getElementById('player-mana-text').textContent = `${Math.max(0, Math.floor(player1.current_mana))}/${player1.max_mana}`;
            
            // Update opponent info
            document.getElementById('opponent-combat-name').textContent = player2.name;
            const opponentHpPercent = (player2.current_hp / player2.max_hp) * 100;
            document.getElementById('opponent-hp-fill').style.width = opponentHpPercent + '%';
            document.getElementById('opponent-hp-text').textContent = `${Math.max(0, Math.floor(player2.current_hp))}/${player2.max_hp}`;
            
            // Update toggles
            const attackToggle = document.getElementById('auto-attack-toggle');
            const abilityToggle = document.getElementById('auto-ability-toggle');
            if (player1.auto_attack_enabled) {
                attackToggle.classList.add('active');
            } else {
                attackToggle.classList.remove('active');
            }
            if (player1.auto_ability_enabled) {
                abilityToggle.classList.add('active');
            } else {
                abilityToggle.classList.remove('active');
            }
            
            // Update status effects
            updateStatusEffects('player-status-effects', player1.buffs || {}, player1.debuffs || {});
            updateStatusEffects('opponent-status-effects', player2.buffs || {}, player2.debuffs || {});
            
            // Update stance selector
            const stanceSelect = document.getElementById('combat-stance-select');
            if (stanceSelect && player1.combat_stance) {
                stanceSelect.value = player1.combat_stance;
            }
            
            // Update combat log
            const logEl = document.getElementById('combat-log');
            logEl.innerHTML = '';
            for (const entry of combat.combat_log.slice(-20)) {  // Show last 20 entries
                const entryDiv = document.createElement('div');
                entryDiv.className = 'combat-log-entry';
                entryDiv.textContent = entry;
                logEl.appendChild(entryDiv);
            }
            logEl.scrollTop = logEl.scrollHeight;
        }
        
        function processVisualEvents(events) {
            if (!events || events.length === 0) return;
            
            const playerIcon = document.getElementById('player-icon');
            const opponentIcon = document.getElementById('opponent-icon');
            const playerContainer = document.getElementById('player-icon-container');
            const opponentContainer = document.getElementById('opponent-icon-container');
            const damageContainer = document.getElementById('damage-numbers-container');
            const arena = document.getElementById('combat-arena');
            
            // Debug logging
            console.log('processVisualEvents called with', events.length, 'events:', events);
            
            if (!playerIcon) {
                console.error('Missing player-icon element');
            }
            if (!opponentIcon) {
                console.error('Missing opponent-icon element');
            }
            if (!damageContainer) {
                console.error('Missing damage-numbers-container element');
            }
            if (!arena) {
                console.error('Missing combat-arena element');
            }
            
            if (!playerIcon || !opponentIcon || !damageContainer || !arena) {
                console.error('Missing combat elements - cannot process visual events');
                return;
            }
            
            for (const event of events) {
                console.log('Processing event type:', event.type, 'Full event:', event);
                
                if (event.type === 'attack') {
                    console.log('Attack event - attacker:', event.attacker, 'defender:', event.defender);
                    // Attacker moves towards defender
                    const attackerIcon = event.attacker === 'player1' ? playerIcon : opponentIcon;
                    const isPlayerAttacking = event.attacker === 'player1';
                    
                    // Add direction-aware attack animation
                    if (isPlayerAttacking) {
                        attackerIcon.style.animation = 'attackMoveRight 0.5s ease-in-out';
                    } else {
                        attackerIcon.style.animation = 'attackMoveLeft 0.5s ease-in-out';
                    }
                    
                    attackerIcon.classList.add('attacking');
                    setTimeout(() => {
                        attackerIcon.classList.remove('attacking');
                        attackerIcon.style.animation = '';
                    }, 500);
                } else if (event.type === 'hit') {
                    console.log('Hit event - target:', event.target, 'damage:', event.damage, 'crit:', event.is_crit);
                    // Defender shakes when hit
                    const targetIcon = event.target === 'player1' ? playerIcon : opponentIcon;
                    const targetContainer = event.target === 'player1' ? playerContainer : opponentContainer;
                    
                    console.log('Adding hit class to icon, creating splat and damage text');
                    targetIcon.classList.add('hit');
                    setTimeout(() => {
                        targetIcon.classList.remove('hit');
                    }, 400);
                    
                    // Show hit splat
                    const splatEl = document.createElement('div');
                    splatEl.className = 'hit-splat ' + (event.is_crit ? 'crit' : '');
                    const rect = targetContainer.getBoundingClientRect();
                    const arenaRect = arena.getBoundingClientRect();
                    splatEl.style.left = (rect.left - arenaRect.left + rect.width / 2 - 30) + 'px';
                    splatEl.style.top = (rect.top - arenaRect.top + rect.height / 2 - 30) + 'px';
                    damageContainer.appendChild(splatEl);
                    setTimeout(() => splatEl.remove(), 600);
                    
                    // Show floating damage number
                    if (event.damage !== undefined) {
                        const damageEl = document.createElement('div');
                        const damageClass = event.is_crit ? 'crit' : (event.is_ability ? 'ability' : 'normal');
                        damageEl.className = 'floating-damage ' + damageClass;
                        
                        if (event.is_crit) {
                            damageEl.textContent = `CRIT! ${event.damage}`;
                        } else if (event.is_ability && event.ability_name) {
                            damageEl.textContent = `${event.ability_name}: -${event.damage}`;
                        } else {
                            damageEl.textContent = `-${event.damage}`;
                        }
                        
                        // Position relative to target with random offset
                        const offsetX = (Math.random() - 0.5) * 40;
                        damageEl.style.left = (rect.left - arenaRect.left + rect.width / 2 + offsetX) + 'px';
                        damageEl.style.top = (rect.top - arenaRect.top - 10) + 'px';
                        
                        damageContainer.appendChild(damageEl);
                        
                        // Remove after animation
                        setTimeout(() => {
                            damageEl.remove();
                        }, event.is_crit ? 2500 : 2000);
                    }
                } else if (event.type === 'dodge') {
                    // Defender moves away when dodging
                    const targetIcon = event.target === 'player1' ? playerIcon : opponentIcon;
                    const targetContainer = event.target === 'player1' ? playerContainer : opponentContainer;
                    
                    targetIcon.classList.add('dodging');
                    setTimeout(() => {
                        targetIcon.classList.remove('dodging');
                    }, 400);
                    
                    // Show dodge text
                    const statusEl = document.createElement('div');
                    statusEl.className = 'combat-status-text dodge';
                    statusEl.textContent = 'DODGE!';
                    const rect = targetContainer.getBoundingClientRect();
                    const arenaRect = arena.getBoundingClientRect();
                    statusEl.style.left = (rect.left - arenaRect.left + rect.width / 2 - 40) + 'px';
                    statusEl.style.top = (rect.top - arenaRect.top) + 'px';
                    damageContainer.appendChild(statusEl);
                    setTimeout(() => statusEl.remove(), 1500);
                } else if (event.type === 'parry') {
                    // Defender blocks when parrying
                    const targetIcon = event.target === 'player1' ? playerIcon : opponentIcon;
                    const targetContainer = event.target === 'player1' ? playerContainer : opponentContainer;
                    
                    targetIcon.classList.add('parrying');
                    setTimeout(() => {
                        targetIcon.classList.remove('parrying');
                    }, 400);
                    
                    // Show parry text
                    const statusEl = document.createElement('div');
                    statusEl.className = 'combat-status-text parry';
                    statusEl.textContent = 'PARRY!';
                    const rect = targetContainer.getBoundingClientRect();
                    const arenaRect = arena.getBoundingClientRect();
                    statusEl.style.left = (rect.left - arenaRect.left + rect.width / 2 - 40) + 'px';
                    statusEl.style.top = (rect.top - arenaRect.top) + 'px';
                    damageContainer.appendChild(statusEl);
                    setTimeout(() => statusEl.remove(), 1500);
                } else if (event.type === 'miss') {
                    // Show miss animation
                    const targetIcon = event.target === 'player1' ? playerIcon : opponentIcon;
                    const targetContainer = event.target === 'player1' ? playerContainer : opponentContainer;
                    
                    targetIcon.classList.add('missing');
                    setTimeout(() => {
                        targetIcon.classList.remove('missing');
                    }, 300);
                    
                    // Show miss text
                    const statusEl = document.createElement('div');
                    statusEl.className = 'combat-status-text miss';
                    statusEl.textContent = 'MISS!';
                    const rect = targetContainer.getBoundingClientRect();
                    const arenaRect = arena.getBoundingClientRect();
                    statusEl.style.left = (rect.left - arenaRect.left + rect.width / 2 - 35) + 'px';
                    statusEl.style.top = (rect.top - arenaRect.top) + 'px';
                    damageContainer.appendChild(statusEl);
                    setTimeout(() => statusEl.remove(), 1500);
                } else if (event.type === 'ability') {
                    // Ability use animation (brief flash)
                    const attackerIcon = event.attacker === 'player1' ? playerIcon : opponentIcon;
                    const attackerContainer = event.attacker === 'player1' ? playerContainer : opponentContainer;
                    
                    attackerIcon.classList.add('ability-cast');
                    setTimeout(() => {
                        attackerIcon.classList.remove('ability-cast');
                    }, 600);
                    
                    // Show ability name text if available
                    if (event.ability_name) {
                        const abilityEl = document.createElement('div');
                        abilityEl.className = 'combat-status-text';
                        abilityEl.style.color = '#6bcf7f';
                        abilityEl.textContent = event.ability_name + '!';
                        const rect = attackerContainer.getBoundingClientRect();
                        const arenaRect = arena.getBoundingClientRect();
                        abilityEl.style.left = (rect.left - arenaRect.left + rect.width / 2 - 50) + 'px';
                        abilityEl.style.top = (rect.top - arenaRect.top - 30) + 'px';
                        damageContainer.appendChild(abilityEl);
                        setTimeout(() => abilityEl.remove(), 1500);
                    }
                }
            }
        }
        
        async function loadAbilities() {
            if (!currentCharacterId) return;
            
            try {
                const response = await authenticatedFetch(`/api/abilities/list?character_id=${currentCharacterId}`);
                const result = await response.json();
                
                if (result.success) {
                    abilityLoadout = result.loadout || {};
                    const hotkeysEl = document.getElementById('ability-hotkeys');
                    hotkeysEl.innerHTML = '';
                    
                    // Show all available abilities, not just assigned ones
                    if (result.abilities && result.abilities.length > 0) {
                        // First, show assigned abilities in their slots
                        for (let slot = 1; slot <= 4; slot++) {
                            const abilityId = abilityLoadout[slot];
                            const ability = result.abilities.find(a => a.id === abilityId);
                            
                            const slotDiv = document.createElement('div');
                            slotDiv.style.cssText = 'padding: 10px; border: 1px solid var(--border-color); border-radius: 8px; text-align: center; min-height: 80px; display: flex; flex-direction: column; justify-content: center;';
                            
                            if (ability) {
                                const isUltimate = ability.is_ultimate;
                                if (isUltimate) {
                                    slotDiv.style.borderColor = 'var(--warning)';
                                    slotDiv.style.background = 'rgba(245, 158, 11, 0.1)';
                                }
                                
                                slotDiv.innerHTML = `
                                    <div style="font-weight: 600; font-size: 0.9em;">${ability.name}</div>
                                    <div style="font-size: 0.75em; color: var(--text-secondary); margin-top: 5px;">${ability.cooldown_seconds}s</div>
                                    <button onclick="useAbility('${ability.id}')" style="margin-top: 5px; padding: 5px 10px; background: var(--accent-primary); color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 0.85em;">Use</button>
                                `;
                            } else {
                                slotDiv.innerHTML = `<div style="color: var(--text-secondary); font-size: 0.9em;">Slot ${slot}</div>`;
                            }
                            
                            hotkeysEl.appendChild(slotDiv);
                        }
                        
                        // Show unassigned abilities below
                        const unassignedAbilities = result.abilities.filter(a => !Object.values(abilityLoadout).includes(a.id));
                        if (unassignedAbilities.length > 0) {
                            const unassignedDiv = document.createElement('div');
                            unassignedDiv.style.cssText = 'grid-column: 1 / -1; margin-top: 15px; padding: 10px; background: var(--bg-tertiary); border-radius: 8px;';
                            unassignedDiv.innerHTML = '<div style="font-weight: 600; margin-bottom: 10px; font-size: 0.9em;">Available Abilities (not assigned):</div>';
                            
                            const abilitiesGrid = document.createElement('div');
                            abilitiesGrid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;';
                            
                            for (const ability of unassignedAbilities) {
                                const abilityDiv = document.createElement('div');
                                abilityDiv.style.cssText = 'padding: 10px; border: 1px solid var(--border-color); border-radius: 8px; text-align: center;';
                                
                                const isUltimate = ability.is_ultimate;
                                if (isUltimate) {
                                    abilityDiv.style.borderColor = 'var(--warning)';
                                    abilityDiv.style.background = 'rgba(245, 158, 11, 0.1)';
                                }
                                
                                abilityDiv.innerHTML = `
                                    <div style="font-weight: 600; font-size: 0.9em;">${ability.name}</div>
                                    <div style="font-size: 0.75em; color: var(--text-secondary); margin-top: 5px;">${ability.description}</div>
                                    <div style="font-size: 0.75em; color: var(--text-secondary); margin-top: 5px;">Cooldown: ${ability.cooldown_seconds}s</div>
                                    <button onclick="useAbility('${ability.id}')" style="margin-top: 5px; padding: 5px 10px; background: var(--accent-primary); color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 0.85em;">Use</button>
                                `;
                                
                                abilitiesGrid.appendChild(abilityDiv);
                            }
                            
                            unassignedDiv.appendChild(abilitiesGrid);
                            hotkeysEl.appendChild(unassignedDiv);
                        }
                    } else {
                        // No abilities available - show message
                        hotkeysEl.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); padding: 20px;">No abilities available. Equip a weapon to unlock abilities.</div>';
                    }
                } else {
                    console.error('Failed to load abilities:', result);
                }
            } catch (error) {
                console.error('Error loading abilities:', error);
            }
        }
        
        async function useAbility(abilityId) {
            if (!currentCombatId || !currentCharacterId) return;
            
            try {
                const response = await authenticatedFetch(`/api/combat/ability/${currentCombatId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        character_id: currentCharacterId,
                        ability_id: abilityId
                    })
                });
                
                const result = await response.json();
                if (!result.success) {
                    alert('Error using ability: ' + (result.detail || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error using ability:', error);
            }
        }
        
        async function toggleAutoAttack() {
            if (!currentCombatId || !currentCharacterId) return;
            
            const toggle = document.getElementById('auto-attack-toggle');
            const enabled = !toggle.classList.contains('active');
            
            try {
                const response = await authenticatedFetch(`/api/combat/auto-toggle/${currentCombatId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        character_id: currentCharacterId,
                        toggle_type: 'attack',
                        enabled: enabled
                    })
                });
                
                if (response.ok) {
                    toggle.classList.toggle('active');
                }
            } catch (error) {
                console.error('Error toggling auto attack:', error);
            }
        }
        
        async function toggleAutoAbility() {
            if (!currentCombatId || !currentCharacterId) return;
            
            const toggle = document.getElementById('auto-ability-toggle');
            const enabled = !toggle.classList.contains('active');
            
            try {
                const response = await authenticatedFetch(`/api/combat/auto-toggle/${currentCombatId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        character_id: currentCharacterId,
                        toggle_type: 'ability',
                        enabled: enabled
                    })
                });
                
                if (response.ok) {
                    toggle.classList.toggle('active');
                }
            } catch (error) {
                console.error('Error toggling auto ability:', error);
            }
        }
        
        async function endCombat() {
            if (combatPollInterval) {
                clearInterval(combatPollInterval);
                combatPollInterval = null;
            }
            
            if (currentCombatId) {
                try {
                    await authenticatedFetch(`/api/combat/end/${currentCombatId}`);
                } catch (error) {
                    console.error('Error ending combat:', error);
                }
            }
            
            hideActiveCombat();
            currentCombatId = null;
            await refreshCharacterData();
        }
        
        async function tryMatch() {
            if (!currentCharacterId) return;
            
            try {
                const response = await authenticatedFetch('/api/pvp/match', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ character_id: currentCharacterId })
                });
                
                const result = await response.json();
                if (result.success && result.opponent_id) {
                    startCombat(result.opponent_id, true);
                } else {
                    alert('No opponents available. You will be matched when someone joins.');
                }
            } catch (error) {
                console.error('Error matching:', error);
            }
        }
        
        async function togglePvPEnabled() {
            if (!currentCharacterId) return;
            
            try {
                const response = await authenticatedFetch('/api/pvp/toggle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        character_id: currentCharacterId,
                        enabled: true
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    alert('PvP enabled! Other players can now challenge you.');
                    loadPvPOpponents();
                }
            } catch (error) {
                console.error('Error toggling PvP:', error);
            }
        }
        
        async function startAutoFight(enemyId) {
            if (!currentCharacterId) return;
            
            if (!confirm('Start auto-fight for 1 hour? You can stop early, but rewards are only applied when the session completes or is stopped.')) {
                return;
            }
            
            try {
                const response = await authenticatedFetch('/api/pve/auto-fight', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        character_id: currentCharacterId,
                        enemy_id: enemyId
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    currentAutoFightSessionId = result.session_id;
                    showAutoFightModal();
                    startAutoFightPolling();
                } else {
                    alert('Error starting auto-fight: ' + (result.detail || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error starting auto-fight:', error);
                alert('Error starting auto-fight');
            }
        }
        
        function showAutoFightModal() {
            document.getElementById('auto-fight-modal').classList.add('active');
        }
        
        function closeAutoFightModal() {
            document.getElementById('auto-fight-modal').classList.remove('active');
        }
        
        function startAutoFightPolling() {
            if (autoFightPollInterval) {
                clearInterval(autoFightPollInterval);
            }
            
            autoFightPollInterval = setInterval(async () => {
                if (!currentAutoFightSessionId) {
                    clearInterval(autoFightPollInterval);
                    return;
                }
                
                try {
                    const response = await authenticatedFetch(`/api/pve/auto-fight/${currentAutoFightSessionId}`);
                    const result = await response.json();
                    
                    if (result.success) {
                        updateAutoFightDisplay(result.session);
                        
                        if (!result.session.is_active) {
                            clearInterval(autoFightPollInterval);
                            autoFightPollInterval = null;
                            showAutoFightResults(result.session);
                            currentAutoFightSessionId = null;
                            await refreshCharacterData();
                        }
                    }
                } catch (error) {
                    console.error('Error polling auto-fight:', error);
                }
            }, 2000);  // Poll every 2 seconds
        }
        
        function updateAutoFightDisplay(session) {
            const timeRemaining = session.time_remaining;
            const minutes = Math.floor(timeRemaining / 60);
            const seconds = timeRemaining % 60;
            
            document.getElementById('auto-fight-time').textContent = `${minutes}:${String(seconds).padStart(2, '0')}`;
            document.getElementById('auto-fight-wins').textContent = session.wins;
            document.getElementById('auto-fight-losses').textContent = session.losses;
            document.getElementById('auto-fight-exp').textContent = session.total_exp_gained;
            document.getElementById('auto-fight-gold').textContent = session.total_gold_gained;
            document.getElementById('auto-fight-items').textContent = session.items_dropped_count;
        }
        
        function showAutoFightResults(session) {
            const resultsEl = document.getElementById('auto-fight-results');
            resultsEl.style.display = 'block';
            resultsEl.innerHTML = `
                <h3 style="margin-bottom: 15px;">Auto-Fight Complete!</h3>
                <div style="text-align: left;">
                    <p><strong>Enemy:</strong> ${session.enemy_name}</p>
                    <p><strong>Wins:</strong> ${session.wins}</p>
                    <p><strong>Losses:</strong> ${session.losses}</p>
                    <p><strong>Win Rate:</strong> ${session.wins + session.losses > 0 ? ((session.wins / (session.wins + session.losses)) * 100).toFixed(1) : 0}%</p>
                    <p><strong>Total EXP Gained:</strong> ${session.total_exp_gained}</p>
                    <p><strong>Total Gold Gained:</strong> ${session.total_gold_gained}</p>
                    <p><strong>Items Dropped:</strong> ${session.items_dropped_count}</p>
                    <p><strong>Level Ups:</strong> ${session.level_ups}</p>
                    <p><strong>Total Damage Dealt:</strong> ${session.total_damage_dealt.toLocaleString()}</p>
                    <p><strong>Total Damage Taken:</strong> ${session.total_damage_taken.toLocaleString()}</p>
                    <p><strong>Critical Hits:</strong> ${session.total_crits}</p>
                    <p><strong>Dodges:</strong> ${session.total_dodges}</p>
                    ${session.fastest_victory ? `<p><strong>Fastest Victory:</strong> ${session.fastest_victory} turns</p>` : ''}
                    ${session.slowest_victory ? `<p><strong>Slowest Victory:</strong> ${session.slowest_victory} turns</p>` : ''}
                </div>
            `;
            document.getElementById('auto-fight-close-btn').style.display = 'block';
        }
        
        async function stopAutoFight() {
            if (!currentAutoFightSessionId) return;
            
            if (!confirm('Stop auto-fight session? All rewards will be applied now.')) {
                return;
            }
            
            try {
                const response = await authenticatedFetch(`/api/pve/auto-fight/${currentAutoFightSessionId}/stop`, {
                    method: 'POST'
                });
                
                const result = await response.json();
                
                if (result.success) {
                    if (autoFightPollInterval) {
                        clearInterval(autoFightPollInterval);
                        autoFightPollInterval = null;
                    }
                    
                    // Get final results
                    const statusResponse = await fetch(`/api/pve/auto-fight/${currentAutoFightSessionId}`);
                    const statusResult = await statusResponse.json();
                    
                    if (statusResult.success) {
                        showAutoFightResults(statusResult.session);
                    }
                    
                    currentAutoFightSessionId = null;
                    await refreshCharacterData();
                }
            } catch (error) {
                console.error('Error stopping auto-fight:', error);
            }
        }

        async function extendAutoFight(hours) {
            if (!currentAutoFightSessionId) return;

            const costs = {
                1: 2000,
                2: 3500,
                4: 6000
            };
            const cost = costs[hours];

            if (!confirm(`Extend auto-fight session by ${hours} hour(s)?\n\nCost: ${cost} gold`)) {
                return;
            }

            try {
                const response = await authenticatedFetch(`/api/pve/auto-fight/extend`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        session_id: currentAutoFightSessionId,
                        hours: hours
                    })
                });

                const result = await response.json();
                
                if (result.success) {
                    await refreshCharacterData();
                    // Update the time display
                    const timeEl = document.getElementById('auto-fight-time');
                    if (timeEl) {
                        const minutes = Math.floor(result.time_remaining / 60);
                        const seconds = result.time_remaining % 60;
                        timeEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    }
                    alert(`Auto-fight extended by ${hours} hour(s)! Gold spent: ${result.gold_spent}, Remaining: ${result.gold_remaining}`);
                } else {
                    alert('Error extending auto-fight: ' + (result.detail || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error extending auto-fight:', error);
                alert('Error extending auto-fight');
            }
        }

        // Chat functions
        async function loadChatMessages() {
            try {
                const response = await authenticatedFetch('/api/chat/get?limit=50');
                const result = await response.json();
                
                if (result.success) {
                    const messagesEl = document.getElementById('chat-messages');
                    messagesEl.innerHTML = '';

                    for (const msg of result.messages) {
                        const msgDiv = document.createElement('div');
                        msgDiv.className = 'chat-message';
                        msgDiv.innerHTML = `
                            <div class="chat-message-header">
                                <span class="chat-character-name">${msg.character_name}</span>
                                <span class="chat-timestamp">${new Date(msg.timestamp).toLocaleTimeString()}</span>
                            </div>
                            <div class="chat-message-text">${msg.message}</div>
                        `;
                        messagesEl.appendChild(msgDiv);
                    }

                    messagesEl.scrollTop = messagesEl.scrollHeight;
                }
            } catch (error) {
                console.error('Error loading chat:', error);
            }
            }

        async function updateOnlineCount() {
            try {
                const response = await authenticatedFetch('/api/players/online-count');
                const result = await response.json();
                if (result.success) {
                    document.getElementById('online-count').textContent = result.online_count;
                }
            } catch (error) {
                console.error('Error updating online count:', error);
            }
        }

        async function sendChatMessage() {
            if (!currentCharacterId) {
                alert('Please create a character first');
                return;
            }

            const input = document.getElementById('chat-input');
            const message = input.value.trim();

            if (!message) return;

            try {
                const response = await authenticatedFetch('/api/chat/send', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        character_id: currentCharacterId,
                        message: message
                    })
                });

                const result = await response.json();
                
                if (result.success) {
                    input.value = '';
                    loadChatMessages();
                } else {
                    alert('Error sending message: ' + (result.detail || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error sending chat:', error);
                alert('Error sending message');
            }
        }

        // Navigation
        function showScreen(screenName) {
            // Hide all screens
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });

            // Remove active from all nav buttons
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected screen
            document.getElementById(`${screenName}-screen`).classList.add('active');
            event.target.classList.add('active');
            
            // Load data for specific screens
            if (screenName === 'combat') {
                loadPvEEnemies();
                loadPvPOpponents();
            } else if (screenName === 'store') {
                loadStoreItems();
            } else if (screenName === 'leaderboard') {
                loadLeaderboard();
            } else if (screenName === 'chat') {
                loadChatMessages();
            }
        }
        
        // Store functions
        async function loadStoreItems() {
            if (!currentCharacterId) return;
            
            try {
                const response = await authenticatedFetch(`/api/store/list?character_id=${currentCharacterId}`);
                const result = await response.json();
                
                if (result.success) {
                    const gridEl = document.getElementById('store-items-grid');
                    gridEl.innerHTML = '';
                    
                    if (result.items.length === 0) {
                        gridEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary); grid-column: 1/-1;">No items available</p>';
                        return;
                    }
                    
                    for (const item of result.items) {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'inventory-item';
                        
                        itemDiv.innerHTML = `
                            <div class="item-rarity rarity-common">COMMON</div>
                            <div class="item-name">${item.name}</div>
                            <div class="item-stats" style="margin: 10px 0;">Level ${item.level_requirement}+</div>
                            <div style="font-weight: 600; color: var(--text-accent); margin: 10px 0;">${item.price} Gold</div>
                            <div class="item-actions">
                                <button class="item-action-btn equip-btn" onclick="buyStoreItem('${item.id}')">Buy</button>
                            </div>
                        `;
                        
                        gridEl.appendChild(itemDiv);
                    }
                }
            } catch (error) {
                console.error('Error loading store items:', error);
            }
        }
        
        async function buyStoreItem(itemId) {
            if (!currentCharacterId) return;
            
            if (!confirm('Purchase this item?')) return;
            
            try {
                const response = await authenticatedFetch('/api/store/buy', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        character_id: currentCharacterId,
                        item_id: itemId
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    alert(`Purchased! Item added to inventory.`);
                    await refreshCharacterData();
                    loadStoreItems();
                } else {
                    alert('Error purchasing item: ' + (result.detail || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error buying item:', error);
                alert('Error purchasing item');
            }
        }
        
        async function forgeItem(rarity) {
            if (!currentCharacterId) return;
            
            const costs = {
                'common': 50, 'uncommon': 200, 'rare': 500,
                'epic': 1500, 'legendary': 5000, 'mythic': 20000
            };
            
            if (!confirm(`Forge a random ${rarity} item for ${costs[rarity]} gold?`)) return;
            
            try {
                const response = await authenticatedFetch('/api/store/forge', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        character_id: currentCharacterId,
                        rarity: rarity
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    alert(`Forged ${result.equipment.name}!`);
                    await refreshCharacterData();
                } else {
                    alert('Error forging item: ' + (result.detail || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error forging item:', error);
                alert('Error forging item');
            }
        }
        
        let combineSelectedItems = [];
        
        function showCombineModal() {
            if (!characterData || !characterData.inventory) {
                alert('No items to combine');
                return;
            }
            
            combineSelectedItems = [];
            const listEl = document.getElementById('combine-items-list');
            listEl.innerHTML = '';
            
            // Group items by rarity
            const itemsByRarity = {};
            for (const item of characterData.inventory) {
                const rarity = item.rarity || 'common';
                if (!itemsByRarity[rarity]) {
                    itemsByRarity[rarity] = [];
                }
                itemsByRarity[rarity].push(item);
            }
            
            for (const [rarity, items] of Object.entries(itemsByRarity)) {
                const rarityDiv = document.createElement('div');
                rarityDiv.style.marginBottom = '15px';
                rarityDiv.innerHTML = `<h4 style="margin-bottom: 5px; text-transform: capitalize;">${rarity}</h4>`;
                
                for (const item of items) {
                    const itemDiv = document.createElement('div');
                    itemDiv.style.cssText = 'padding: 8px; margin: 5px 0; border: 1px solid var(--border-color); border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 10px;';
                    itemDiv.onclick = () => toggleCombineItem(item.id, itemDiv);
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = combineSelectedItems.includes(item.id);
                    checkbox.style.pointerEvents = 'none';
                    
                    itemDiv.appendChild(checkbox);
                    itemDiv.innerHTML += `<span>${item.name} (Lv ${item.level || 1})</span>`;
                    
                    rarityDiv.appendChild(itemDiv);
                }
                
                listEl.appendChild(rarityDiv);
            }
            
            document.getElementById('combine-modal').classList.add('active');
        }
        
        function toggleCombineItem(itemId, element) {
            const index = combineSelectedItems.indexOf(itemId);
            if (index > -1) {
                combineSelectedItems.splice(index, 1);
                element.style.background = '';
            } else {
                combineSelectedItems.push(itemId);
                element.style.background = 'rgba(99, 102, 241, 0.2)';
            }
            element.querySelector('input[type="checkbox"]').checked = combineSelectedItems.includes(itemId);
        }
        
        function closeCombineModal() {
            document.getElementById('combine-modal').classList.remove('active');
            combineSelectedItems = [];
        }
        
        async function confirmCombine() {
            if (!currentCharacterId || combineSelectedItems.length < 2) {
                alert('Select at least 2 items to combine');
                return;
            }
            
            try {
                const response = await authenticatedFetch('/api/store/combine', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        character_id: currentCharacterId,
                        item_ids: combineSelectedItems
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    alert(`Combined items into ${result.equipment.name} (${result.rarity_created})!`);
                    closeCombineModal();
                    await refreshCharacterData();
                } else {
                    alert('Error combining items: ' + (result.detail || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error combining items:', error);
                alert('Error combining items');
            }
        }

        // Character creation
        function showCharacterModal() {
            document.getElementById('character-modal').classList.add('active');
        }

        function closeCharacterModal() {
            document.getElementById('character-modal').classList.remove('active');
        }

        async function createCharacter() {
            const nameInput = document.getElementById('character-name-input');
            const name = nameInput.value.trim();

            if (!name || name.length < 3) {
                alert('Character name must be at least 3 characters');
                return;
            }
            if (!currentUserId) {
                alert('User information missing. Please log in again.');
                return;
            }

            try {
                const response = await authenticatedFetch('/api/character/create', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: name, user_id: currentUserId })
                });

                const result = await response.json();
                
                if (result.success) {
                    currentCharacterId = result.character_id;
                    localStorage.setItem(CHARACTER_ID_KEY, currentCharacterId);
                    closeCharacterModal();
                    await refreshCharacterData();
                } else {
                    alert('Error creating character: ' + (result.detail || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error creating character:', error);
                alert('Error creating character');
            }
        }

        function logout() {
            if (confirm('Are you sure you want to logout?')) {
                localStorage.removeItem(TOKEN_KEY);
                localStorage.removeItem(REFRESH_TOKEN_KEY);
                localStorage.removeItem(USER_ID_KEY);
                localStorage.removeItem(CHARACTER_ID_KEY);
                localStorage.removeItem(USERNAME_KEY);
                window.location.href = '/';
            }
        }
    </script>
</body>
</html>

